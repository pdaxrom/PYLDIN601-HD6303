
;***************************
;*			   *
;*    MOTOROLA	MC6800	   *
;*			   *
;*	  ASSEMBLER	   *
;*			   *
;* FOR PYLDIN 601 COMPUTER *
;*			   *
;*	VERSION 2.05	   *
;*			   *
;*	  1-MAR-90	   *
;*			   *
;* (C) 1989 TODOR TODOROV  *
;*			   *
;***************************


	CMD


; CONSTANTS

LINSIZE =	81		;MAXIMUM LINE SIZE SUPPORTED
STKSIZE =	64		;MAXIMUM STACK SPACE USED DURING ASSEMBLY
SYMBOLS =	2048		;MAXIMUM NUMBER OF SYMBOLS+1 (POWER OF 2, >=128)
				;(147 RESERVED SYMBOLS)
LOCALS	=	256		;MAXIMUM NUMBER OF LOCALS+1 (POWER OF 2, >=256)
GLOBALS =	24		;MAXIMUM NUMBER OF EXTERNALS+ENTRIES ( <= 24)
MAXSLEN =	8		;MAXIMUM SYMBOL LENGTH ALLOWED ( <= 8)
SECTSIZ =	512		;FILE SECTOR SIZE (POWER OF 2, >=256)

BELL	=	7		;BELL CHARACTER
BS	=	8		;BACKSPACE CHARACTER
TABCHAR =	9		;FIELD DELIMITER
LF	=	10		;LINE FEED CHARACTER
FF	=	12		;FORM FEED CHARACTER
CR	=	13		;CARRIAGE RETURN CHARACTER
EOFCHR	=	26		;END OF FILE CHARACTER
COMMENT =	';'             ;COMMENT DELIMITER


; VARIABLES

	SECT	$80

LCLHASH DW	0		;LOCALS HASH TABLE START ADDRESS
LINTAB	DW	0		;LINE BUFFER ADDRESS (FILE BUFFER TOP)
BUFTAB	DW	0		;FILE BUFFER ADDRESS (LOCALS HASH TABLE TOP)
BUFLEN	DW	0		;FILE BUFFER LENGTH
HASHTAB DW	0		;HASH TABLE START ADDRESS (LINE BUFFER TOP)
RELTAB	DW	0		;RELATIVE TABLE BOTTOM ADDRESS (HASH TABLE TOP)
RELPTR	DW	0		;RELATIVE TABLE TOP ADDRESS
LCLPTR	DW	0		;LOCALS SYMBOL TABLE BOTTOM ADDRESS
OBJTAB	DW	0		;OBJECT CODE START ADDRESS
OBJPTR	DW	0		;POINTER TO NEXT OBJECT BYTE
SYMPTR	DW	0		;SYMBOL TABLE BOTTOM ADDRESS
SYMTAB	DW	0		;SYMBOL TABLE TOP ADDRESS
LIMIT	DW	0		;STACK LIMIT

STACK	DW	0		;SAVED VALUE OF STACK POINTER
LINADR	DW	0		;ADDRESS OF LINE IN FILE BUFFER
EXECADR DW	0		;START ADDRESS OF PROGRAM
BUFBYT	DW	0		;NUMBER OF BYTES LEFT IN FILE BUFFER
CHKADR	DW	0		;ADDRESS IN RELATIVE TABLE CORRESPONDING TO THE
				;"CHECKSUM" ITEM (IF = 0 THEN NO CHECKSUM)
TMP	DW	0		;TEMPORARY USED BY ALL(!) ROUTINES
LENADR	DW	0		;ADDRESS IN RELATIVE TABLE CORRESPONDING TO THE
				;"STRING LENGTH" ITEM (USED BY STR)
LINCNT	DW	0		;NUMBER OF LINE CURRENTLY IN BUFFER
ERRCNT	DW	0		;NUMBER OF ERRORS OCCURED
OBJCNT	DW	0		;NUMBER OF OBJECT BYTES GENERATED
RELCNT	DW	0		;NUMBER OF ITEMS IN RELATIVE TABLE
PC	DW	0		;CURRENT VALUE OF PROGRAM COUNTER
OLDPC	DW	0		;SAVED VALUE OF PROGRAM COUNTER (FOR RE-ORG)
LINPC	DW	0		;PROGRAM COUNTER AT THE START OF CURRENT LINE
DATALEN DW	0		;LENGTH OF DATA SEGMENT
GBLCNT	DFB	0		;NUMBER OF EXTERNALS+ENTRIES
EXTCNT	DFB	0		;NUMBER OF EXTERNALS
SYMCNT	DW	0		;NUMBER OF SYMBOLS IN HASH TABLE
LCLCNT	DW	0		;NUMBER OF SYMBOLS IN LOCAL HASH TABLE
OBJADJ	DW	0		;ADDRESS IN MEMORY WHERE FIRST OBJECT BYTE
				;IS SUPPOSED TO BE
RELOBJ	DW	0		;ADDRESS IN RELATIVE TABLE CORRESPONDING TO THE
				;FIRST OBJECT BYTE IN MEMORY
RELADJ	DW	0		;ADDRESS IN RELATIVE TABLE TO START GARBAGE
				;COLLECTION FROM
RELGBL	DW	0		;ADDRESS IN RELATIVE TABLE CORRESPONDING TO THE
				;CURRENT GLOBAL LABEL
TXTPTR	DW	0		;ADDRESS OF CURRENT CHARACTER IN LINE
FOUND	DFB	0		;BIT 0 = 1 IF RELATIVE (EXPR)
				;BIT 1 = 1 IF LO-BYTE (EXPR)
				;BIT 2 = 1 IF HI-BYTE (EXPR)
				;BIT 5 = 1 IF EXTERNAL (EXPR)
				;BIT 6 = 1 IF LOCAL SYMBOL (FINDSYM,ADDSYM,EXPR)
				;BIT 7 = 0 IF SYMBOL FOUND (FINDSYM,ADDSYM,EXPR)
SYMLEN	DFB	0		;LENGTH OF SYMBOL FOUND (ALSO USED BY MAINASM)
SYMADR	DW	0		;ADDRESS OF SYMBOL FOUND
VALADR	DW	0		;ADDRESS OF SYMBOL VALUE-1
LABTYP	DFB	0		;TYPE OF LABEL:
				; = 0 IF LABEL NOT PRESENT
				; <> 0 IF LABEL PRESENT
				;BIT 7 = 0 IF DUPLICATE LABEL
				;BIT 6 = 1 IF LOCAL LABEL
				;BIT 3 = 1 IF PATCH CALLED
				;BIT 0 = 1 IF RELATIVE LABEL
LABADR	DW	0		;SYMADR OF LABEL
LABVAL	DW	0		;VALADR OF LABEL
VAL	DW	0		;TERM VALUE
VALUE	DW	0		;EXPRESSION VALUE
RESADR	DW	0		;SYMADR OF THE "X" SYMBOL
MNEMBUF DS	6		;INSTRUCTION MNEMONIC BUFFER (INITASM)
				;ALSO USED BY PUTDECW
OLDTYP	DFB	0		;TYPE OF PREVIOUS SECTION: $20 = ABS, 0 = REL
SECTYP	DFB	0		;CURRENT SECTION TYPE: $20 = ABS, 0 = REL
SECTFL	DFB	0		;IF =$10 THEN IN DUMMY SECTION (IF =0 THEN NOT)
LASTADR DW	0		;ENDING ADDRESS OF THE LAST DUMMY SECTION
LASTYP	DFB	0		;TYPE OF THE LAST DUMMY SECTION
CMDFL	DFB	0		; = 0, WE DON'T KNOW WHAT TO GENERATE
				; = 1, .CMD FILE CAN'T BE GENERATED
				; = -1, .CMD FILE IS TO BE GENERATED
				; = -2, .OBJ HEADER HAS ALREADY BEEN WRITTEN
CHKVAL	DFB	0		;CHECKSUM VALUE
EOF	DFB	0		; <> 0 IF EOF IS REACHED
FIRST	DFB	0		;USED BY EXPR: BIT 0 - FIRSTREL
				;	       BIT 1 - LOW BYTE
				;	       BIT 2 - HIGH BYTE
				;	       BIT 4 - FIRSTFL
				;	       BIT 5 - FIRSTEXT
				;	       BIT 6 - FIRSTLCL
				;	       BIT 7 - FIRSTFND
				;ALSO USED BY INITASM
PAGLIN	DFB	0		;LINE NUMBER IN CURRENT LISTING PAGE
PAGSIZ	DFB	0		;PAGE SIZE IN LINES
SAVADR	DW	0		;SAVED ORG BEFORE DUMMY SECTION
SAVTYP	DFB	0		;SAVED SECTYP BEFORE DUMMY SECTION
LISTFL	DFB	0		; = 0 TO GENERATE LISTING FILE
				; = $FF TO GENERATE OBJECT FILE
				; = 1 FOR LIST OFF
HANDLE	DFB	0		;FILE HANDLE OF SOURCE FILE
OUTHNDL DFB	0		;FILE HANDLE OF OUTPUT FILE
TMP0	DW	0		;TEMPORARY USED (EXPR,MAINASM,INITASM)
OP	DW	0		;USED BY EXPR
TMP5	=	OP		;TEMPORARY USED (GC,PRERR,MAINASM)
				;GC MAY USE HI-BYTE ONLY (LO-BYTE USED BY EXPR)!
TMP6	=	TMP5+1		;TEMPORARY USED (DS)
RELADR	DW	0		;ADDRESS IN RELATIVE TABLE (PATCH)
TMP3	=	RELADR		;TEMPORARY USED (GC,TERM,MAINASM)
				;GC MAY USE LO-BYTE ONLY (HI-BYTE USED BY TERM)!
HASHPTR DW	0		;HASH ADDRESS OF SYMBOL FOUND (FINDSYM,ADDSYM)
TMP4	=	HASHPTR 	;TEMPORARY USED (GC,MAINASM,PRERR)
SYMCHR	DW	0		;ADDRESS OF FIRST SYMBOL CHAR (FINDSYM,ADDSYM)
TMP1	=	SYMCHR		;TEMPORARY USED (GC,MAINASM,WRITE)
CHRSYM	DW	0		;ADDRESS OF LAST SYMBOL CHAR (FINDSYM,ADDSYM)
TMP2	=	CHRSYM		;TEMPORARY USED (GC,MAINASM,WRITE)

	ERR	./$100

	ENDS

; STRUCTURE OF RELATIVE TABLE ITEM

	SECT	0

TYPE	DFB	0		;RELATIVE ITEM TYPE
				;BIT 0 - LOW BYTE PRESENT
				;BIT 1 - HIGH BYTE PRESENT
				;(IF BOTH ARE PRESENT THEN WORD VALUE,
				; IF BOTH ARE NOT PRESENT THEN FORCE LOW BYTE)
				;BIT 2 - BRANCH (1 = 11-BYTE)
				;BIT 3 - LENGTH (1 = 5-BYTE)
				;BIT 4 - DUMMY SECTION (IF NOT DEFINED)
				;      - EXTERNAL (IF DEFINED)
				;BIT 5 - SECTION TYPE (1 = ABSOLUTE)
				;BIT 6 - RELATIVE (IF DEFINED)
				;      - GLOBAL (IF NOT DEFINED)
				;BIT 7 - DEFINED
				;(IF SYMBOL IS NOT DEFINED THEN IT IS RELATIVE)
				;(IF SYMBOL IS NOT DEFINED THEN NOT EXTERNAL)
SYMVAL				;VALUE OF SYMBOL (IF DEFINED)
LINE	DW	0		;LINE NUMBER OF ITEM (IF NOT DEFINED)
OFFSET	DW	0		;OFFSET IN OBJECT/LISTING
CHAIN	DW	0		;POINTER TO NEXT ITEM FOR THIS SYMBOL
LINK	DW	0		;POINTER TO ITEM THAT POINTS TO THIS ITEM
PCNT	DW	0		;PROGRAM COUNTER (BRANCHES ONLY)

	ENDS


MAINASM JMP	INITASM
	ASC	'UniASM version 2.05 (w) Todor Todorov, 1-Mar-1990.'

:DOHASH LDX	OBJTAB		;ZERO LOCAL SYMBOL TABLE
	STX	LCLPTR
	LDX	RELGBL		;LOOP TO FIND ANY UNDEFINED LOCAL SYMBOLS
:FLUSH	CPX	RELPTR
	BEQ	:INIHSH
	LDAA	TYPE,X
	CMPA	#$40
	BCC	:DONTDO
	JSR	PRERR11
	LDX	RELGBL
	JSR	:ZTYP		;RELEASE UNDEFINED LOCALS FROM THE REL TABLE
:DONTDO JSR	NXTITEM
	STX	RELGBL
	BRA	:FLUSH
:INIHSH CLRA			;ZERO LOCAL HASH TABLE
	STS	TMP
	SEI
	LDX	BUFTAB
	TXS
	LDX	#LOCALS
:INILCL PSHA
	PSHA
	DEX
	BNE	:INILCL
	LDS	TMP
	CLI
	STAA	LCLCNT
	STAA	LCLCNT+1
	RTS
LIST	=	.		;LIST DIRECTIVE
	LDAA	LISTFL
	BMI	:STARTX
	JSR	CHKEOLZ
	BEQ	:SETFLG 	;TOGGLE LIST
	BSR	:TMPEXP
	ORAA	VALUE+1
	BEQ	:SETFLG
	LDAA	#1
:SETFLG EORA	#1
	STAA	LISTFL
:STARTX BRA	:STARTS 	;DON'T ECHO THE DIRECTIVE TO THE LISTING
PAGE	=	.
	JSR	CHKEOLZ
	BEQ	:FFOUT		;DON'T SET PAGE SIZE
	BSR	:TMPEXP
	BNE	:ERR14
	LDAB	VALUE+1
	CMPB	#4
	BCS	:ERR14
	STAB	PAGSIZ
:FFOUT	LDAA	LISTFL		;SEND FF TO LISTING
	BNE	:STARTS
	STAA	TMP2
	LDAB	PAGLIN
	BEQ	:STARTS
	JSR	:WRFF
	BRA	:STARTS 	;DON'T ECHO THE DIRECTIVE TO THE LISTING
ERR	=	.
	JSR	CHKEOLZ
	BEQ	:ERR18		;ALWAYS ERR
	BSR	:TMPEXP
	ORAA	VALUE+1
	BNE	:ERR18
	RTS
INITENT =	.		;MAIN ENTRY FOR FIRST TIME
	BSR	:INIHSH
	BRA	:START
:TMPEXP BSR	EXPRABS
	JSR	FINISH
	LDAA	VALUE
:TMPRTS RTS
EXPRABS =	.		;EVALUATE ABSOLUTE EXPRESSION WITH NO
	JSR	EXPRASM 	;FORWARD REFERENCES IN IT
	BCC	:TMPRTS
ERR12	=	.		;INVALID EXPRESSION TYPE
	LDAB	#12
	DFB	$7D
:ERR14	LDAB	#14		;INVELID EXPRESSION SIZE
	DFB	$7D
:ERR18	LDAB	#18		;USER BREAK
ERROR	=	.		;COMMON ERROR ENTRY
	JSR	PRERRL
	LDX	PC		;FOR PATCH
	STX	VALUE
LOOP	=	.
	LDAA	LISTFL		;DO A LISTING FOR THE CURRENT LINE
	BNE	:STARTS
	JSR	NEWLINE
	LDAB	LINPC
	JSR	:WRBYTE
	LDAB	LINPC+1
	JSR	:WRBYTE
	LDX	#':'*$100!TABCHAR
	JSR	:TWOCHR
	LDX	#'  '           ;ADJUST RIGHT
	STX	MNEMBUF
	STX	MNEMBUF+2
	STX	MNEMBUF+4
	LDX	LINCNT
	JSR	PUTDECW
	LDX	#MNEMBUF
	JSR	ECHOSTR
	JSR	TABOUT
	LDX	LINTAB
	JSR	ECHOSTR
:STARTS LDS	STACK
	JSR	PATCH		;RESTORE STACK POINTER IN CASE OF AN ERROR
:START	LDAB	EOF		;PROCEED NEXT LINE
	BNE	:ENDALL
	LDX	LINCNT
	INX
	STX	LINCNT
	BNE	:GOMOVE
	JMP	ERR3
:GOMOVE LDX	LINTAB
:MOVE	STX	TXTPTR
:MOVE1	LDX	BUFBYT
	BNE	:READOK
	PSHB			;READ NEXT SECTOR PRINTING LINE NUM
	JSR	PRLNUM
	PULB
	LDX	BUFTAB
	STX	LINADR
	LDX	#BUFTAB
	LDAA	HANDLE
	INT	$4C
	JSR	TSTFUCK
	STX	BUFBYT
	BEQ	:NOEOF
:READOK DEX
	STX	BUFBYT
	LDX	LINADR
	LDAA	X
	INX
	STX	LINADR
	CMPA	#LF		;LF MEANS NOTHING
	BEQ	:MOVE1
	LDX	TXTPTR
	CMPB	#LINSIZE-1
	BEQ	:SKIPSV 	;TRUNCATE LINE
	STAA	X
	BEQ	:MOVE1
	INX
	INCB
:SKIPSV CMPA	#CR
	BEQ	:MOVED
	CMPA	#EOFCHR
	BNE	:MOVE
:NOEOF	INC	EOF
:MOVED	LDX	TXTPTR
	CLR	X
	LDX	PC
	STX	LINPC
	JMP	:ASSEM
END	=	.		;END DIRECTIVE
	JSR	FINISHZ
:ENDALL LDAB	CHKVAL		;END ASSEMBLY
	NEGB
	CLRA
	JSR	SETVAL
	LDX	#CHKADR-1
	JSR	PTCHABS 	;PATCH CHECKSUM
	LDX	LINTAB
	LDAA	X
	LDX	LINCNT
	TSTA
	BNE	:PRLIN		;IF LAST LINE NOT EMPTY
	DEX
	STX	LINCNT
:PRLIN	JSR	PRLNUM		;PRINT LAST LINE NUM
	LDAA	#' '            ;TO DELETE AN EXTRA CHARACTER
	INT	$22
	LDAA	#BS
	INT	$22
	LDX	RELADJ		;LOOP TO FIND ANY UNDEFINED SYMBOLS
:RELLUP CPX	RELPTR
	BEQ	:EXIT
	LDAA	TYPE,X
	BMI	:DONE
	STX	TMP0
	JSR	PRERR11
	LDX	TMP0
	BSR	:ZTYP		;RELEASE UNDEFINED SYMBOLS FROM THE REL TABLE
:DONE	BSR	NXTITEM
	BRA	:RELLUP
:ZTYP	LDAA	TYPE,X
	ANDA	#$2F		;CLEAR "EXTERNAL" AND "GLOBAL" BITS
DEFTYP	=	.		;SET "DEFINE" BIT
	ORAA	#$80
	STAA	TYPE,X
	RTS

; FIND NEXT ITEM IN RELATIVE TABLE
;
; INPUT:
;   A = 0,X
; OUTPUT:
;   X = NEXT ITEM

NXTITEM =	.
	BITA	#8		;"LENGTH" BIT
	BNE	ADD5
	BITA	#4		;"BRANCH" BIT
	BEQ	:ADD9
	INX
	INX
:ADD9	BSR	ADD4
ADD5	=	.
	INX
ADD4	=	.
	INX
	INX
	INX
	INX
	RTS
:EXIT	LDAA	#$13		;FINAL PROCESSING
	JSR	COLLECT 	;PREPARE REL TABLE FOR WRITING TO DISK
	LDAB	SYMPTR+1
	LDAA	SYMPTR
	SUBB	RELPTR+1
	SBCA	RELPTR
	SUBB	TMP2+1
	SBCA	TMP2
	STAB	TMP3+1		;FREE MEMORY
	STAA	TMP3
	CLR	TMP2		;NEEDED BY CHROUT
	LDAA	LISTFL		;IF LISTING THEN NOTHING TO DO
	BPL	:GOLIST
	LDAA	CMDFL		;IF .CMD THEN ALL IS DONE
	CMPA	#$FE
	BEQ	:DOOBJ
:GOLIST JMP	:DOLIST
:DOOBJ	LDX	RELCNT		;WRITE RELCNT TO DISK
	JSR	:TWOCHR
	LDAB	RELPTR+1	;WRITE REL TABLE TO DISK
	LDAA	RELPTR
	SUBB	RELTAB+1
	SBCA	RELTAB
	STAB	RELPTR+1
	STAA	RELPTR
	LDX	#RELTAB
	JSR	:WRITE
	TAB			;WRITE THE FINAL 0 TO DISK
	JSR	:CHROUT
	JSR	SEEK		;SEEK TO THE BEGINNING OF FILE
	LDX	LINTAB		;ZERO FILE BUFFER
:ZBUFF	DEX
	STAA	X
	CPX	BUFTAB
	BNE	:ZBUFF
	LDAA	#$5A		;.OBJ SIGNATURE
	STAA	X
	COMA
	STAA	1,X
	INC	3,X
	LDAB	EXTCNT
	STAB	7,X		;EXTERNALS
	SUBB	GBLCNT
	NEGB
	STAB	5,X		;ENTRIES
	STAB	TMP2		;EXTERNAL BASE
	LDAB	OBJCNT+1	;OBJECT LENGTH
	LDAA	OBJCNT
	STAB	9,X
	STAA	8,X
	LDAB	#>SECTSIZ	;OBJECT OFFSET WITHIN FILE
	STAB	12,X
	LDAB	EXECADR+1	;START ADDRESS
	LDAA	EXECADR
	STAB	15,X
	STAA	14,X
	LDAB	DATALEN+1	;SIZE OF DATA SEGMENT
	LDAA	DATALEN
	STAB	17,X
	STAA	16,X
	STX	TMP1		;ENTRY BASE
	LDX	SYMPTR		;PREPARE EXTERNALS AND ENTRIES FOR WRITING
:DUMPXN CPX	SYMTAB
	BEQ	:WRHEAD
	LDAA	X
	ANDA	#7
	JSR	:ADDPTR 	;NEXT ITEM IN SYMBOL TABLE
	LDAA	X
	ANDA	#$18
	BEQ	:NXTGBL 	;ABSOLUTE SYMBOL
	CMPA	#$18
	BEQ	:NXTGBL 	;RELATIVE SYMBOL
	SEI
	TXS
	LDX	TMP1
	STX	TMP
	ANDA	#8
	BNE	:ESTLEN 	;ENTRIES ARE WRITTEN SEQUENTALLY
	LDX	SYMPTR		;CALCULATE OFFSET OF EXTERNAL WITHIN HEADER
	LDAB	2,X		;BY ITS NUMBER
	ADDB	TMP2
	ASLB
	ASLB
	STAB	TMP+1
	ASLB
	ASLB
	ROLA
	ADDB	TMP+1
	ADCA	#0
	ADDB	BUFTAB+1
	ADCA	BUFTAB
	STAB	TMP+1
	STAA	TMP
	LDX	TMP
:ESTLEN PULA			;MOVE NAME
	ANDA	#7
:MOVNAM PULB
	STAB	32,X
	INX
	DECA
	BPL	:MOVNAM
	PULA
	PULB
	LDS	STACK
	CLI
	BCC	:NXTGBL 	;EXTERNAL
	LDX	TMP		;MOVE VALUE
	STAB	49,X
	STAA	48,X
	LDAA	#20
	ADDA	TMP1+1		;ENTRY BASE
	STAA	TMP1+1
	BCC	:NXTGBL
	INC	TMP1
:NXTGBL LDX	SYMPTR		;ADJUST TO NEXT SYMBOL
	INX
	INX
	INX
	STX	SYMPTR
	BRA	:DUMPXN
:WRHEAD JSR	WRITEBF 	;WRITE .OBJ HEADER TO DISK
:DOLIST LDAA	LISTFL
	BNE	:SKPINI
	STAA	TMP+1		;NUMBER OF SYMBOLS WRITTEN AT THIS LINE
	LDAA	#MESLEN 	;WRITE INIT MESSAGE
	JSR	:WRINI
	LDAA	#1		;NEW PAGE
	STAA	PAGLIN
:SKPINI LDX	#0		;RESET SYMBOL COUNT
	STX	SYMCNT
	LDX	HASHTAB
	STX	HASHPTR 	;USED AS TOP MARGIN FOR SORTING
:COMPRS STX	SYMPTR		;REMOVE ZEROES AND SPECIAL SYMBOLS
	LDX	X		;FROM THE HASH TABLE, COUNTING SYMBOLS LEFT
	BEQ	:EMPTY
	CPX	RESADR
	BEQ	:EMPTY
	LDAB	X
	BITB	#$20
	BNE	:EMPTY
	LDX	SYMPTR
	LDAB	1,X
	LDAA	0,X
	LDX	HASHPTR
	STAB	1,X
	STAA	0,X
	INX
	INX
	STX	HASHPTR
	LDX	SYMCNT
	INX
	STX	SYMCNT
:EMPTY	LDX	SYMPTR
	INX
	INX
	CPX	RELTAB
	BNE	:COMPRS
	LDAA	LISTFL
	BNE	:CLOSE		;NOTHING TO DO
:LUPLST LDX	HASHTAB
	CPX	HASHPTR
	BEQ	:FINLST 	;HASH TABLE EMPTY
	STX	SYMADR
	SEI
:CHANGE STX	TMP1
	LDX	X
	STX	SYMPTR
:MINLUP LDX	SYMADR		;FIND MINIMUM SYMBOL IN HASH [HASHTAB..HASHPTR]
	INX			;TMP1 IS ITS ADDRESS IN HASH TABLE
	INX			;SYMPTR IS ITS ADDRESS IN SYMBOL TABLE
	CPX	HASHPTR 	;SYMADR USED AS A LOOP VARIABLE
	BEQ	:MINOUT
	STX	SYMADR
	LDX	SYMPTR
	TXS
	PULB
	ANDB	#7
	STAB	SYMLEN
	LDX	SYMADR
	LDX	X
	LDAB	X
	ANDB	#7
:CMPSTR INX
	PULA
	CMPA	X
	BNE	:TSTCHG
	DEC	SYMLEN
	BMI	:MINLUP
	DECB
	BPL	:CMPSTR
:TSTCHG BCS	:MINLUP
	LDX	SYMADR		;LESS
	BRA	:CHANGE
:MINOUT LDS	STACK
	CLI
	DEX			;REMOVE LAST SYMBOL FROM HASH TABLE
	DEX
	STX	HASHPTR
	LDAB	1,X		;REPLACE MINIMUM SYMBOL WITH THE SYMBOL
	LDAA	0,X
	LDX	TMP1
	STAB	1,X
	STAA	0,X
	BSR	:SYMOUT 	;WRITE MINIMUM SYMBOL
	LDAA	TMP2+1
	DECA
	BNE	:LUPLST 	;SYMBOL WAS UNDEFINED, NO SPACES
	LDAA	TMP5+1
	BNE	:ONESPC
	JSR	:SPCOUT 	;SYMBOLS WAS A ZERO PAGE ONE, 3 SPACES
	JSR	:SPCOUT
:ONESPC JSR	:SPCOUT 	;ELSE ONE SPACE ONLY
	BRA	:LUPLST
:FINLST JSR	:WRTMPN 	;TWO CRS AT THE END OF LISTING
	JSR	:WRTMPN
:CLOSE	LDAA	OUTHNDL
	INT	$4E
	JSR	TSTFUCK
	LDX	#LINMES 	;FINAL MESSAGES
	INT	$23
	LDX	ERRCNT
	BSR	:PRDEC
	LDX	#SYMMES
	INT	$23
	LDX	SYMCNT
	BSR	:PRDEC
	LDX	#OBJMES
	INT	$23
	LDX	OBJCNT
	BSR	:PRDEC
	JSR	NL
	INT	$23
	LDX	TMP3
	BSR	:PRDEC
	LDX	#MEMMES
EXITASM =	.
	INT	$23		;EXIT WITH A MESSAGE
	INT	$38
:PRDEC	JMP	PRDECW		;TO SAVE SPACE
:ADDPTR INCA			;ADD SYMBOL LENGTH TO SYMPTR
	TAB
	ADDB	SYMPTR+1
	STAB	SYMPTR+1
	BCC	:ADDOK
	INC	SYMPTR
:ADDOK	RTS
:SYMOUT LDAA	TMP+1		;WRITE SYMBOL TABLE ITEM
	BNE	:SKIPCR
	BSR	NEWLINE
:SKIPCR INCA
	ANDA	#3		;4 SYMBOLS PER LINE
	STAA	TMP+1
	BSR	:SPCOUT
	BSR	:SPCOUT
	LDX	SYMPTR
	LDAA	X
	LDAB	#'!'
	TSTA
	BPL	:TMPOUT 	;UNDEFINED
	LDAB	#'?'
	ASLA
	BPL	:TMPOUT 	;UNUSED
	LDAB	#'*'
	ANDA	#$30
	CMPA	#$20
	BEQ	:TMPOUT 	;EXTERNAL & USED
	LDAB	#' '
:TMPOUT BSR	:CHROUT
	BSR	:SPCOUT
	LDX	SYMPTR
	LDAA	X
	PSHA
	INX
	ANDA	#7
	PSHA
	BSR	:ADDPTR
	BSR	WRTMPX		;WRITE SYMBOL NAME
	PULA
	EORA	#7
	LDX	#SPACES
	BSR	WRTMPX		;ADD SPACES
	PULA
	TSTA
	BPL	:UNDEFD 	;IF UNDEFINED, IT HAS NO VALUE
	PSHA
	LDX	#'=$'           ;WRITE "=$"
	BSR	:TWOCHR
	PULA
	LDX	SYMPTR
	LDAB	1,X
	STAB	TMP5+1
	BITA	#8
	BNE	:OUTBYT
	TSTB
	BEQ	:BYTOUT 	;ZERO-PAGE
:OUTBYT STAA	TMP5+1
	BSR	:WRBYTE
	LDX	SYMPTR
:BYTOUT LDAB	2,X
:WRBYTE PSHB			;WRITE HEX BYTE
	LSRB
	LSRB
	LSRB
	LSRB
	BSR	:DIGOUT
	PULB
	ANDB	#$F
:DIGOUT ORAB	#'0'            ;WRITE HEX DIGIT
	CMPB	#':'
	BCS	:CHROUT
	ADDB	#7
	DFB	$7D
TABOUT	=	.		;WRITE TAB
	LDAB	#TABCHAR
	DFB	$7D
:SPCOUT LDAB	#' '            ;WRITE " "
:CHROUT STAB	TMP5		;WRITE CHAR
	LDAA	#1
	BRA	WRTMPV
NEWLINE =	.		;WRITE CR IN LISTING
	STAA	TMP2
	BSR	:TESTFF
:WRTMPN LDX	#CR*$100+LF
:TWOCHR STX	TMP5		;WRITE 2 CHARS
	LDAA	#2
WRTMPV	=	.
	LDX	#TMP5
WRTMPX	=	.		;WRITE STRING (X = ADRS, A = LEN)
	STX	TMP1
	DFB	$7D
:UNDEFD LDAA	#7
WRTMPL	=	.
	STAA	TMP2+1
WRTMP	=	.		;WRITE DATA (TMP1 = ADRS, TMP2 = LEN)
	LDX	#TMP1
:WRITE	LDAA	OUTHNDL
	INT	$4D
TSTFUCK =	.		;TEST FOR I/O ERROR AFTER DOS CALL
	TSTA
	BEQ	:EXIT1
	CLRB
	LDX	#ERRTXT 	;I/O ERROR
	JSR	PRERRX
	LDX	LINTAB
	INT	$3D
	JMP	EXITASM
WRITEBF =	.		;WRITE SECTOR BUFFER
	LDX	#BUFTAB
	BRA	:WRITE
:TESTFF INC	PAGLIN		;TEST IF END OF PAGE IS REACHED
	LDAA	PAGLIN
	EORA	PAGSIZ
	BNE	:EXIT1
:WRFF	STAA	PAGLIN		;WRITE FF IN LISTING
	LDAA	#3
:WRINI	LDX	#INIMES
	BRA	WRTMPX
:SKPSPC LDAB	X		;FIND NON-DELIMITER OR EOL
	BEQ	:DONE1
:LOOPSP INX
	BSR	CHKEOL
	BNE	:DONE1
	BCC	:LOOPSP
:DONE1	STX	TXTPTR
	TSTB
:EXIT1	RTS
:SEELH	LSRA			;CALLED BY EXPRASM
	BCS	:CLRHI
	LSRA
	BCC	:EXPXIT
	LDAB	VALUE
	STAB	VALUE+1
:CLRHI	CLR	VALUE
:EXPXIT RTS
CHKEOLZ =	.
	LDX	TXTPTR
CHKEOL	=	.		;TEST FOR DELIMITER OR EOL
	SEC
	LDAB	X
	BEQ	:EOL
	CMPB	#TABCHAR
	BEQ	:EOL
	CMPB	#COMMENT
	SEC
	BEQ	:EOL
	CMPB	#' '
:EOL	RTS
EXPRASM =	.		;EVALUATE EXPRESSION WITH NO FORWARD REFERENCES
	JSR	EXPR
	BMI	ERR11
:TSTHL	LSRA
	BCC	:SEELH
	BITA	#3
	BEQ	:EXPXIT
	JMP	ERR12
:DUPERR LDAB	#4		;SYMBOL ALREADY DEFINED
	JMP	PRERRL
:DEFINE INX			;"=" DIRECTIVE
	CMPB	X
	BEQ	:DOUBLE 	;"==" DIRECTIVE
	LDAA	FOUND
	BMI	:NOTDBL
	BSR	:DUPERR 	;"=" DOESN'T ALLOW REDEFINED SYMBOLS
	LDX	TXTPTR		;TXTPTR-1 WAS SAVED
:DOUBLE INX
:NOTDBL BSR	CHKEOL
	BNE	:ILLCHR
	LDAA	SYMLEN		;HAS NO LABEL
	BEQ	ERR13
	BCS	UNEXP
	BSR	:SKPSPC
	LDAA	FOUND
	JSR	DEFINE
:GOLOOP JMP	LOOP
:ASSEM	LDX	LINTAB		;ASSEMBLE A LINE
	STX	TXTPTR
	CLR	LABTYP		;FOR PATCH CALL
	LDAB	X
	CMPB	#COMMENT
:GOGO	BEQ	:GOLOOP
	CLRB
	SEC
	JSR	ADDSYM		;PROCEED LABEL
	LDX	SYMADR
	STX	LABADR
	LDX	VALADR
	STX	LABVAL
	BSR	CHKEOLZ
	BEQ	:OK
	LDAB	#5		;ILLEGAL CHAR IN LABEL
	DFB	$7D
UNEXP	=	.		;UNEXPECTED END OF FIELD
	LDAB	#15
	DFB	$7D
ERR13	=	.		;MISSING LABEL
	LDAB	#13
	DFB	$7D
ERR11	=	.		;UNDEFINED SYMBOL
	LDAB	#11
	DFB	$7D
:ERR6	LDAB	#6		;INVALID OPCODE
	DFB	$7D
:ILLCHR LDAB	#7		;ILLEGAL CHAR IN OPCODE
	JMP	ERROR
:OK	LDAA	SYMLEN
	STAA	LABTYP
	JSR	:SKPSPC
	CMPB	#'='
	BEQ	:DEFINE
	TSTA
	BEQ	:NOTSYM
	PSHB
	LDAA	FOUND
	BMI	:UNIQUE
	BSR	:DUPERR 	;DUPLICATE LABEL
	LDAA	FOUND
:UNIQUE ASLA
	BMI	:SKPACT 	;LOCAL LABEL
	LDX	LCLCNT		;GLOBAL LABEL, CLEAR LOCAL TABLES
	BEQ	:SKPLCL
:TRICK	BEQ	:ILLCHR
	JSR	:DOHASH
:SKPLCL LDX	RELPTR
	STX	RELGBL
:SKPACT LDAB	FOUND
	LDAA	SECTYP
	BNE	:SETTYP
	INCB
:SETTYP STAB	LABTYP		;SET REL/ABS LABEL TYPE
	PULB
	LDX	PC		;FOR PATCH
	STX	VALUE
:NOTSYM TSTB
	BEQ	:GOGO
	CMPB	#COMMENT
	BEQ	:GOGO
	JSR	FINDOP		;PROCEED OPCODE
	LDX	TXTPTR		;CHECK FOR "EXTENDED" FORCING
	LDAB	X
	EORB	#'*'
	PSHB
	BNE	:SKPNXT
	INX
	STX	TXTPTR
:SKPNXT JSR	CHKEOL
	BNE	:ILLCHR
	LDAA	FOUND
	BMI	:ERR6
	JSR	:SKPSPC
	LDX	VALADR
	LDX	1,X
	CPX	#EQU		;POST-PATCH DIRECTIVES
	BEQ	:SKPPCH
	CPX	#ENT
	BEQ	:SKPPCH
	CPX	#EXT
	BEQ	:SKPPCH
	CPX	#KBD
	BEQ	:SKPPCH
	PSHB			;PRE-PATCH DIRECTIVES, INSTRUCTIONS
	JSR	PATCH
	PULB
:SKPPCH PULA
	STAA	TMP3		;"EXTENDED" FORCE FLAG
	LDX	VALADR
	TST	1,X
	BEQ	:INSTR		;AN INSTRUCTION
	TSTA
	BEQ	:TRICK		;FORCE NOT ALLOWED
	LDX	1,X
	JSR	X		;CALL DIRECTIVE
:GOLUP0 BRA	:GOLUP1 	;ALREADY PATCHED
:INSTR	LDAA	2,X
	ANDA	#$F0
	EORA	#$20
	BEQ	:SETMOD 	;A BRANCH
	LDAA	#$80
:SETMOD STAA	TMP
	LDAA	2,X
	TSTB
	BEQ	:INHER
	CMPB	#COMMENT
	BNE	:NOTINH
:INHER	CMPA	#$60		;INHERENT
	BCC	:ILLMD2 	;NOT ALLOWED
	LDAB	TMP
	COMB
	BMI	:ILLMD3 	;NOT ALLOWED (BRANCH)
	TAB
:GENGO	JSR	GENOBJ
:GOLUP1 JMP	LOOP
:NOTINH CMPA	#$60		;NON-INHERENT
	PSHA
	LDAA	TMP
	BCC	:LEGAL
	BMI	:ILLMD3 	;NOT ALLOWED
:LEGAL	LDX	TXTPTR
	CMPB	#'#'
	CLC
	BNE	:SETIMM
	INX			;IMMEDIATE
	STX	TXTPTR
	SEC
:SETIMM RORA
	LDAB	X
	ANDB	#$DF
	CMPB	#'X'
	SEC
	BNE	:NOTNDX
	STAB	X		;PRE-INDEX
	INX
	LDAB	X
	CMPB	#','
	BEQ	:INDX
	JSR	CHKEOL		;"X" ONLY
	SEC
	BNE	:NOTNDX
	JSR	CLRVAL
	LSRA
	BRA	:SKPEVL
:INDX	INX
	STX	TXTPTR
:NOTNDX RORA
	PSHA
	JSR	EXPR
	PULA
:SKPEVL LDAB	X
	CMPB	#','
	BNE	:SKPIND
	INX			;POST-INDEX
	LDAB	X
	ANDB	#$DF
	CMPB	#'X'
	BNE	:SEEERR
	STAB	X
	ASLA
	BCC	:ILLMOD 	;X,EXPR,X NOT ALLOWED
	LSRA
	INX
:SKPIND ASLA
	BCS	:NOIND
:ILLMD3 BMI	:ILLMOD 	;#EXPR,X NOT ALLOWED
:NOIND	RORA
	JSR	FINISH
	PULB
	BITA	#$20
	BEQ	:BRANCH
	CMPB	#$8D
	BNE	:NBRNCH
:BRANCH ASLA			;A BRANCH
:ILLMD2 BCC	:ILLMOD 	;INDEX NOT ALLOWED
	BMI	:ILLMOD 	;IMMEDIATE NOT ALLOWED
	LDAA	FOUND
	JSR	:TSTHL		;> OR < NOT ALLOWED FOR RELATIVE BRANCHES
	LDAA	FOUND
	BPL	:SEEREL
	COMA			;FORWARD BRANCH
	BSR	:TSTTYP 	;EXTERNAL NOT ALLOWED
	LDAB	#4
	JSR	PUTREL		;PUT ITEM TO PATCH
:GENZ	CLRB
:GENGO2 JMP	:GENGO
:SEEREL LSRA			;BACKWARD BRANCH
	RORA
	LSRA
	LSRA
	EORA	SECTYP
	BSR	:TSTTYP 	;SECTION TYPE MUST CORRESPOND TO THE EXPR TYPE
	JSR	GETVAL
	SEC
	SBCB	PC+1
	SBCA	PC
	CMPB	#$80		;DISPLACEMENT
	SBCA	#0
	INCA
	BEQ	:GENGO2
	LDAB	#10		;BRANCH OUT OF RANGE
	JSR	PRERRL
	BRA	:GENZ
:TSTTYP BITA	#$20		;TO SAVE SPACE
	BNE	:GENOBZ
	JMP	ERR12
:GENOBZ JMP	GENOBJ		;TO SAVE SPACE
:TSTIND BCS	:NOTIND
	ADDB	#$20		;INDEXED
:GENLO	BSR	:GENOBZ 	;GEN A BYTE
	JSR	PROCBZ
:GOLUP2 JMP	LOOP
:ILLMOD LDAB	#9		;INVALID ADDRESSING MODE
	DFB	$7D
ERR17	=	.		;OPCODE NOT ALLOWED
	LDAB	#17
:ERR	JMP	ERROR
:SEEERR JSR	TSTEOL		;FIND OUT WHICH ERROR TO PRODUCE
ERR8	=	.
	LDAB	#8		;ILLEGAL CHAR IN OPERAND
	BRA	:ERR
:NBRNCH TSTB			;NOT A BRANCH
	BPL	:TYPE1
	CMPB	#$AD		;JSR
	BEQ	:TYPE1
	ASLA			;2-OPERAND
	BPL	:TSTIND
	TBA
	ANDA	#$BF
	CMPA	#$8E
	BEQ	:GENHI		;LDX,LDS
	ANDA	#$F7
	CMPA	#$87
	BEQ	:ILLMOD 	;STA #
	CMPB	#$8C		;CPX
	BNE	:GENLO
:GENHI	BSR	:GENOBZ 	;GEN A WORD
	JSR	PROCWRD
	BRA	:GOLUP2
:NOTIND ADDB	#$10
	LDAA	FOUND
	BITA	#6
	BNE	:GENLO		;LO/HI = DIRECT
	LSRA
	BCS	:EXTEND 	;RELATIVE
	LDAA	VALUE
	BNE	:EXTEND 	;HI-BYTE NON-ZERO
	LDAA	TMP3
	BNE	:GENLO		;NON-FORCED = DIRECT
:EXTEND ADDB	#$20		;EXTENDED
	BRA	:GENHI
:TYPE1	ASLA			;1-OPERAND
	BMI	:ILLMOD 	;IMMEDIATE NOT ALLOWED
	BCC	:GENLO		;IDEXED
	ADDB	#$10		;EXTENDED
	BRA	:GENHI
INT	=	.		;INT DIRECTIVE
	JSR	EXPR
	BSR	FINISH
	LDAB	#'?'            ;SWI
	BRA	:GENLO
FINISHZ LDX	TXTPTR
FINISH	JSR	CHKEOL		;TEST FOR DELIMITER OR EOL
	BNE	ERR8
	RTS


; END DUMMY SECTION DIRECTIVE

ENDS	BSR	FINISHZ
	LDAA	SECTFL
	BEQ	ERR17		;OUTSIDE DUMMY SECTION
	CLR	SECTFL
	LDAA	SECTYP
	STAA	LASTYP
	LDX	PC
	STX	LASTADR
	LDAA	SAVTYP		;RESTORE TYPE/ADRS
	STAA	SECTYP
	LDX	SAVADR
	STX	PC
	RTS


GOERR17 BRA	ERR17


; MAIN DIRECTIVE

MAIN	BSR	FINISHZ
	LDX	EXECADR
	INX
	BNE	GOERR17
	LDX	OBJCNT
	STX	EXECADR
EXIT2	RTS


; CHECK FOR PRESENCE OF A GLOBAL LABEL

EXTENT	LDAA	LABTYP
	BEQ	GOERR13 	;NO LABEL
	BSR	FINISHZ
	ASLA
	BMI	GOERR13 	;LOCAL LABEL
	LDAA	CMDFL
	INCA
	BEQ	GOERR17 	;.CMD FILE
	LDAB	GBLCNT
	CMPB	#GLOBALS
	INCB
	BCS	EXIT2
	JMP	ERR2		;.OBJ HEADER FULL


; CHECKSUM DIRECTIVE

CHK	JSR	FINISHZ
	LDAB	CMDFL
	INCB
	BNE	GOERR17 	;NOT .CMD FILE
	LDX	CHKADR
	BNE	GOERR17 	;CHK ALREADY IN USE
	LDX	#CHKADR-1
GENFRWD STX	VALADR
	LDAA	#$81
	STAA	FOUND
	JSR	PUTREL		;SET ITEM TO PATCH
	JMP	PUTZERO 	;GEN ZERO TO BE PATCHED


; COMMAND DIRECTIVE

CMD	LDAA	SECTFL		;INSIDE DUMMY SECTION
	ORAA	CMDFL		;CMD ALREADY USED
	BNE	GOERR17
	DEC	CMDFL
	INC	PC
	JSR	CHKEOLZ
	BEQ	SETABS		;ADRS NOT GIVEN
	JSR	EXPRASM
	BCC	FINSET
	INC	CMDFL		;RELATIVE ADRS GIVEN
	DEC	PC
	BSR	SETABS
	BRA	XERR12


; ENTRY DIRECTIVE

ENT	LDX	PC
	STX	VALUE
	JSR	CHKEOLZ
	BEQ	:TSTREL
	CLR	TMP3
	JSR	EXPRASM
	LDAA	TMP3
	BNE	GOERR11 	;RECURSIVE DEFINITION NOT ALLOWED
	BCS	:DOENT		;RELATIVE TYPE
XERR12	=	.
	JMP	ERR12
:TSTREL LDAA	SECTYP
XERR17	=	.
	BNE	GOERR17 	;ABSOLUTE TYPE
:DOENT	BSR	EXTENT
	LDAA	#$91		;SET-UP FOR LABTYP
	BRA	GOPTCH1
GOERR13 JMP	ERR13


; EXTERNAL DIRECTIVE

EXT	BSR	EXTENT
	LDAA	EXTCNT
	STAA	VALUE+1
	CLR	VALUE		;VALUE = EXTCNT
	INC	EXTCNT
	LDAA	#$A1
GOPTCH1 STAB	GBLCNT
GOPATCH STAA	LABTYP
	JMP	PATCH
PTCHABS STX	LABADR
	STX	LABVAL
	LDAA	#$80		;SET-UP FOR LABTYP
	BRA	GOPATCH


; ORIGIN DIRECTIVE

ORG	LDAA	SECTFL		;INSIDE DUMMY SECTION
	BNE	XERR17
	JSR	CHKEOLZ
	BEQ	:REORG
	JSR	EXPRASM
FINSET	=	.
	JSR	GOFINSH
	LDAA	SECTYP		;SAVE TYPE/ADRS FOR RE-ORG
	STAA	OLDTYP
	LDX	PC
	STX	OLDPC
SETPC	=	.		;SET TYPE/ADRS
	JSR	GETVAL
	STAB	PC+1
	STAA	PC
	CLRA
	LDAB	FOUND
	LSRB
	BCS	:SETREL
SETABS	=	.		;SET ABS TYPE FOR CURRENT SECTION
	LDAA	#$20
:SETREL STAA	SECTYP
	RTS
:REORG	LDAA	OLDTYP		;RESTORE TYPE/ADRS FROM PREVIOUS ORG
	STAA	SECTYP
	LDX	OLDPC
	STX	PC
	RTS
GOERR11 JMP	ERR11


; KEYBOARD DIRECTIVE

KBD	LDAB	LABTYP
XERR13	BEQ	GOERR13 	;NO LABEL
	JSR	FINISHZ
:FINDCR LDAB	X		;FIND EOL
	INX
	TSTB
	BNE	:FINDCR
	STX	TXTPTR
	LDX	#GIVEME
	JSR	PRERRX		;GIVE ME A VALUE FOR
	LDX	LABADR
	LDAB	X
	ANDB	#7
:SYMOUT INX
	LDAA	X
	INT	$22		;LABEL
	DECB
	BPL	:SYMOUT
	LDAA	#':'
	INT	$22
	LDAA	#' '
	INT	$22
	SEC
	LDAB	HASHTAB+1
	SBCB	TXTPTR+1
	LDX	TXTPTR		;GETLIN BUFFER AFTER EOL
	INT	$21
	JSR	NL
	BSR	EQU
	JMP	PRLNUM		;PRINT LINE NUMBER


; DUMMY SECTION DIRECTIVE

SECT	JSR	CHKEOLZ
	SEC
	BEQ	:SKIP
	JSR	EXPRASM
	BSR	GOFINSH
	CLC
:SKIP	LDAA	SECTFL
	BNE	:GOSET		;INSIDE DUMMY SECTION
	LDAA	#$10
	STAA	SECTFL
	LDAB	SECTYP		;SAVE TYPE/ADRS
	STAB	SAVTYP
	LDX	PC
	STX	SAVADR
:GOSET	BCC	SETPC		;IF EXPR GIVEN
	LDAB	LASTYP
	STAB	SECTYP
	LDX	LASTADR
	STX	PC
	RTS


; EQUATE DIRECTIVE

EQU	LDAA	LABTYP
	BEQ	XERR13		;NO LABEL
DEFINE	PSHA
	CLR	TMP3
	JSR	EXPRASM
	PULA
	ANDA	#$80
	ORAA	#$10		;TO BE <> 0
	ORAA	FOUND
	BSR	GOFINSH
	LDAB	TMP3
	BNE	GOERR11 	;RECURSIVE DEFINITION NOT ALLOWED
	JMP	GOPATCH


; STRING DIRECTIVE

STR	LDX	LENADR
	BEQ	:PUTREL
	LDAA	#$80		;IF ERROR OCCURED DURING PREVIOUS STR DIRECTIVE
	STAA	TYPE,X
:PUTREL LDX	#LENADR-1
	JSR	GENFRWD 	;SET ITEM TO PATCH
	BSR	DFB		;PROCEED AS USUAL
	LDX	LENADR
	LDAB	OBJCNT+1
	SUBB	OFFSET+1,X
	CLRA
	JSR	SETVAL
	LDX	#LENADR-1
	JSR	PTCHABS 	;PATCH STRING LENGTH
	LDX	#0		;ALL DONE
	STX	LENADR
	RTS


; DEFINE WORD DIRECTIVE

DW	JSR	EXPR		;GEN A WORD
	JSR	PROCWRD
	LDX	TXTPTR
	LDAB	X
	CMPB	#','
	BNE	GOFINSH 	;IF NO "," THEN ALL DONE
	INX
	STX	TXTPTR
	BRA	DW
GOFINSH JMP	FINISH


; DEFINE SPACE DIRECTIVE

DS	JSR	EXPRABS 	;GET COUNT
	JSR	GETVAL
	STAB	TMP6+1
	BSR	CLRVAL
	LDAB	X
	CMPB	#','
	BNE	:GOFIN
	INX			;GET EXPR, IF ANY
	STX	TXTPTR
	PSHA
	JSR	EXPR
	PULA
:GOFIN	STAA	TMP6
	BSR	GOFINSH
	CLR	TMP2		;IF PROCBYT INDENDS TO DO AN ERROR, IT WILL
	LDX	TMP6		;DO IT ONLY FIRST TIME
	BEQ	EXIT3
:REPEAT BSR	PROCBYT 	;GEN NEXT BYTE
	LDX	TMP6
	DEX
	STX	TMP6
	BNE	:REPEAT
EXIT3	RTS


; CLEAR EXPRESSION VALUE

CLRVAL	CLRB			;TO SAVE SPACE
	STAB	VALUE
	STAB	VALUE+1
	STAB	FOUND
	RTS


; DEFINE BYTE DIRECTIVE

DFB	LDX	TXTPTR
	LDAB	X
	CMPB	#$27
	BNE	:NOTSTR
:NXTCHR INX			;STRING
	LDAB	X
	BEQ	EXIT3
	CMPB	#$27
	BEQ	:FINAL
:QUOTE	STX	TXTPTR
	BSR	GENOBJ		;GEN A CHAR
	LDX	TXTPTR
	BRA	:NXTCHR
:FINAL	INX
	LDAB	X
	BEQ	EXIT3
	CMPB	#$27
	BEQ	:QUOTE		;"''" = "'"
	BRA	:NXTITM
:NOTSTR JSR	EXPR
	BSR	PROCBZ		;GEN A BYTE
	LDX	TXTPTR
	LDAB	X
:NXTITM CMPB	#','
	BNE	GOFINSH 	;IF NO "," THEN ALL DONE
	INX
	STX	TXTPTR
	BRA	DFB


; ASCII DIRECTIVE

ASC	BSR	DFB		;PROCEED AS USUAL
PUTZERO BSR	CLRVAL		;PUT TERMINATING ZERO


; STORE BYTE VALUE IN OBJECT

PROCBZ	CLR	TMP2		;ENABLE ERRORS
PROCBYT LDAA	FOUND
	BITA	#6
	BNE	:SETTYP 	;LO/HI
	LDAA	VALUE
	BNE	:ILLSIZ 	;TOO BIG
:SETTYP CLRB			;SET-UP FOR PUTREL
	LDAA	FOUND
	LSRA
	BITA	#2
	BEQ	:SEEEND
	LDAA	VALUE
	STAA	VALUE+1
:SEEEND BCC	GENBYT		;ABSOLUTE
	LDAA	FOUND
	ANDA	#$86
	BNE	GENBYT		;UNDEFD OR LO/HI
:ILLSIZ LDAA	TMP2		;ERROR FLAG
	BNE	:SKPERR
	LDAB	#14		;INVALID EXPRESSION SIZE
	STAB	TMP2
	JSR	PRERRL
:SKPERR LDAB	#1		;SET-UP FOR PUTREL
	BRA	GENBYT


; STORE WORD VALUE IN OBJECT

PROCWRD LDAA	FOUND
	LSRA
	LSRA
	BCS	:GENZ		;LO
	LSRA
	BCC	:GENWRD
	LDAB	VALUE		;HI
	STAB	VALUE+1
:GENZ	CLRB			;GEN ZERO
	BSR	GENOBJ
	LDAB	#3
GENBYT	=	.
	JSR	PUTREL
	BRA	:GENEND
:GENWRD LDAB	#3		;WORD
	JSR	PUTREL
	LDAB	VALUE		;GEN VALUE
	BSR	GENOBJ
:GENEND LDAB	VALUE+1


; PUT BYTE IN OBJECT CODE
;
; INPUT:
;   B = BYTE TO PUT

GENOBJ	LDX	PC
	INX
	STX	PC
	LDX	DATALEN
	INX
	STX	DATALEN
	LDAA	SECTFL
	BNE	GC		;INSIDE DUMMY SECTION
	STAA	DATALEN
	STAA	DATALEN+1
	JSR	DENYCMD 	;NO .CMD DIRECTIVE AFTER CODE
	LDX	OLDPC
	INX
	STX	OLDPC
	LDX	OBJCNT
	INX
	STX	OBJCNT
	BEQ	ERR3
	LDAA	LISTFL		;NO OBJECT CODE WHILE LISTING
	BPL	GC
	LDX	OBJPTR
	STAB	X
	INX
	STX	OBJPTR
	ADDB	CHKVAL		;CHECKSUM VALUE
	STAB	CHKVAL


; GARBAGE COLLECTION

GC	JSR	:CHKMEM
	BCS	:DOIT
	RTS
:DOIT	LDAA	#$FF		;COMPRESS REL TABLE
	JSR	COLLECT
	LDAB	SYMPTR+1
	LDAA	SYMPTR
	SUBB	OBJPTR+1
	SBCA	OBJPTR
	ADDB	LCLPTR+1
	ADCA	LCLPTR
	ADDB	RELPTR+1
	ADCA	RELPTR
	RORA
	RORB
	STAB	TMP1+1		;NEW LOCATION OF LCLPTR
	STAA	TMP1
	ADDB	OBJPTR+1
	ADCA	OBJPTR
	SUBB	LCLPTR+1
	SBCA	LCLPTR
	STAB	TMP2+1		;NEW LOCATION OF OBJPTR
	STAA	TMP2
	SUBB	OBJPTR+1
	SBCA	OBJPTR
	PSHA
	STS	TMP
	SEI
	BCC	:BACK		;MOVE LOCAL TABLE/OBJECT TO A NEW LOCATION
	LDX	LCLPTR		;MOVE FORWARD
	TXS
	LDX	TMP1
:MOVFD	CPX	TMP2
	BEQ	:EXIT
	PULA
	STAA	X
	INX
	BRA	:MOVFD
:BACK	LDS	TMP2		;MOVE BACKWARD
	LDX	OBJPTR
	DES
:MOVBK	CPX	LCLPTR
	BEQ	:EXIT
	DEX
	LDAA	X
	PSHA
	BRA	:MOVBK
ERR3	=	.		;MEMORY FULL
	LDAB	#3
	JMP	ERROR
:EXIT	LDS	TMP
	CLI			;MOVE DONE
	PULA
	PSHB			;CORRECT OBJADJ/OBJTAB
	PSHA
	ADDB	OBJADJ+1
	ADCA	OBJADJ
	STAB	OBJADJ+1
	STAA	OBJADJ
	PULA
	PULB
	PSHB
	PSHA
	ADDB	OBJTAB+1
	ADCA	OBJTAB
	STAB	OBJTAB+1
	STAA	OBJTAB
	PULA
	PULB
	ADDB	TMP4+1		;TO ADD TO THE POINTERS TO THE LOCAL TABLE
	ADCA	TMP4
	STAB	TMP4+1
	STAA	TMP4
	LDX	TMP1		;CORRECT LCLPTR/OBJPTR
	STX	LCLPTR
	LDX	TMP2
	STX	OBJPTR
	LDX	LCLCNT
	BEQ	:WHATDO 	;LOCAL TABLE EMPTY
	LDX	LCLHASH
:UPDATE LDAB	1,X		;UPDATE LOCAL HASH TABLE POINTERS
	LDAA	0,X
	BEQ	:SKPADJ
	ADDB	TMP4+1
	ADCA	TMP4
	STAB	1,X
	STAA	0,X
:SKPADJ INX
	INX
	CPX	BUFTAB
	BNE	:UPDATE
	LDX	RELGBL
:RELLUP CPX	RELPTR		;UPDATE REL TABLE LINKS
	BEQ	:WHATDO
	LDAA	TYPE,X
	CMPA	#$40
	BCC	:DONE		;NOT LOCAL
	LDAB	LINK+1,X
	LDAA	LINK,X
	CMPA	RELPTR
	BNE	:CMP
	CMPB	RELPTR+1
:CMP	BCS	:WITHIN 	;POINTS TO WITHIN REL TABLE
	ADDB	TMP4+1
	ADCA	TMP4
	STAB	LINK+1,X	;FOR DEFINED LOCALS, LINK WON'T BE CORRECT
	STAA	LINK,X
:WITHIN LDAA	TYPE,X
:DONE	JSR	NXTITEM
	BRA	:RELLUP
:WHATDO BSR	:CHKMEM
	BCC	EXIT1		;MEMORY IS NOT FULL NOW
	LDX	OBJTAB		;MEMORY IS STILL FULL
	CPX	OBJPTR
	BEQ	ERR3
	STX	TMP1
	LDAB	OBJPTR+1
	LDAA	OBJPTR
	SUBB	OBJTAB+1
	SBCA	OBJTAB
	STAB	TMP2+1
	STAA	TMP2
	LDAB	OBJADJ+1	;UPDATE OBJADJ/RELOBJ
	LDAA	OBJADJ
	SUBB	TMP2+1
	SBCA	TMP2
	STAB	OBJADJ+1
	STAA	OBJADJ
	STX	OBJPTR
	LDX	RELPTR
	STX	RELOBJ
	JSR	WRTMP		;WRITE ALL OF OBJECT CODE TO DISK
	JMP	GC		;PROCEED AGAIN
:CHKMEM LDAB	SYMPTR+1	;DETERMINE WHETHER MEMORY IS FULL
	LDAA	SYMPTR
	SUBB	#MAXSLEN+3
	SBCA	#0
	CMPB	OBJPTR+1
	SBCA	OBJPTR
	BCS	EXIT1		;SYMBOL TABLE/OBJECT CONFLICT
	LDAB	OBJTAB+1
	LDAA	OBJTAB
	SUBB	#MAXSLEN+3+11
	SBCA	#0
	CMPB	RELPTR+1
	SBCA	RELPTR		;LOCAL SYMBOL/REL TABLE CONFLICT
EXIT1	RTS


; COLLECT RELATIVE TABLE ITEMS
;
; INPUT:
;   A = $13 FOR FINAL PROCESSING
;   A = $FF FOR GARBAGE COLLECTION

:EXIT	LDS	TMP
	CLI
	LDAB	RELADJ+1
	LDAA	RELADJ
	BSR	:CMPADJ
	BCS	:SETPTR 	;RELADJ CORRESPONDING TO ALREADY WRITTEN BYTE
	STAB	RELOBJ+1
	STAA	RELOBJ
:SETPTR LDX	TMP1		;UPDATE RELPTR
	STX	RELPTR
	LDX	OBJTAB
	CPX	OBJPTR
	BEQ	:SKPSKP 	;IF LISTING, THEN TMP4 VALUE INVALID FOR OBJCNT
	LDAA	CMDFL		;IS INVALID
	BMI	:SKPHDR
	COM	CMDFL
	JSR	WRITEBF 	;RESERVE DISK SPACE FOR .OBJ HEADER
:SKPHDR LDX	OBJTAB
	LDAB	TMP4+1
	LDAA	TMP4
	DFB	$7D
:SKPSKP CLRA
	TAB
	STX	TMP1
	ADDB	OBJADJ+1
	ADCA	OBJADJ
	STAB	OBJTAB+1
	STAA	OBJTAB
	SUBB	TMP1+1
	SBCA	TMP1
	STAB	TMP2+1
	STAA	TMP2
	JSR	WRTMP		;WRITE PATCHED PART OF OBJECT
	STX	TMP4
	LDX	OBJTAB		;MOVE LOCAL SYMBOL TABLE OVER OBJECT PART
	SEI			;JUST WRITTEN.	THIS COULD BE OPTIMIZED
	TXS
	LDX	TMP1
:MOVLCL CPX	LCLPTR
	BEQ	:MOVED
	DEX
	LDAA	X
	PSHA
	BRA	:MOVLCL
:MOVED	TSX
	LDS	TMP
	CLI
	STX	LCLPTR		;UPDATE LCLPTR
:CMPADJ CMPA	RELOBJ		;TO SAVE SPACE
	BNE	:CMP
	CMPB	RELOBJ+1
:CMP	RTS
COLLECT =	.
	STAA	TMP5		;SAVE AND MASK
	STS	TMP
	LDX	OBJCNT
	STX	TMP4
	SEI
	LDX	RELADJ
	LDS	RELPTR
	STS	RELADJ
	TXS
:LOOP	STX	TMP1
	BRA	:WHILE
:LOOPX	LDX	RELCNT		;DISCARD REL TABLE ITEM
	DEX
	STX	RELCNT
:WHILE	TSX
	CPX	RELPTR
	BEQ	:EXIT		;ALL DONE
	CPX	RELGBL		;UPDATE SOME VALUABLE POINTERS TO REL TABLE
	BNE	:NOADJ1
	LDX	TMP1
	STX	RELGBL
	TSX
:NOADJ1 CPX	CHKADR
	BNE	:NOADJ2
	LDX	TMP1
	STX	CHKADR
	TSX
:NOADJ2 CPX	LENADR
	BNE	:NOADJ3
	LDX	TMP1
	STX	LENADR
:NOADJ3 LDX	TMP1
	PULB
	TBA
	STAA	TMP3+1		;SAVE TYPE
	ANDA	TMP5		;MOVE ITEM
	STAA	TYPE,X
	LDAA	#4
	BITB	#8
	BNE	:MOVLUP
	LDAA	#8
	BITB	#4
	BEQ	:MOVLUP
	LDAA	#10
:MOVLUP PULB
	INX
	STAB	X
	DECA
	BNE	:MOVLUP
	INX
	STX	TMP2
	LDAB	TMP3+1
	BMI	:TRUNC		;ITEM DEFINED, MUST BE TRUNCATED
	LDAB	TMP1+1
	LDAA	TMP1
	LDX	TMP4
	CPX	OBJCNT
	BNE	:SETCHN 	;RELADJ ALREADY SET
	LDX	TMP1		;SET RELADJ TO 1ST UNPATCHED REL TABLE ITEM
	STX	RELADJ		;THAT CORRESPONDING TO A OBJECT BYTE IN MEMORY
	BSR	:CMPADJ
	BCS	:SETCHN
	LDX	OFFSET,X
	STX	TMP4
:SETCHN LDX	TMP1		;UPDATE POINTERS
	LDX	CHAIN,X
	BEQ	:SETLNK
	STAB	LINK+1,X
	STAA	LINK,X
:SETLNK LDX	TMP1
	LDX	LINK,X
	STAB	CHAIN+1,X
	STAA	CHAIN,X
	LDX	TMP2
:XLOOP	BRA	:LOOP
:TRUNC	BITB	#$40
	BEQ	:LOOPX		;DISCARD ITEM
	ORAB	#8		;TRUNCATE ITEM
	ANDB	TMP5
	BITB	#$90
	BMI	:SPECL		;GC IN PROGRESS
	BEQ	:SPECL		;NOT AN EXTERNAL
	EORB	#$90		;TRANSFER 4TH TO 7TH BIT
:SPECL	LDX	TMP1
	STAB	TYPE,X
	INX
	INX
	INX
	INX
	INX
	BRA	:XLOOP


; PUT RELATIVE ITEM
;
; INPUT:
;   B = 4 IF BRANCH
;   B = 3 IF WORD VALUE
;   B = 0 IF BYTE VALUE

PUTREL	LDAA	FOUND
	LSRA
	BCS	:RELTYP 	;RELATIVE SYMBOL
:EXIT	RTS
:RELTYP LDX	RELPTR
	ANDA	#$13
	BITA	#3
	BNE	:SETTYP 	;LO/HI
	ABA			;SET LO/HI/BRANCH BITS
:SETTYP ORAA	#$C8		;SET DEFINED/RELATIVE/LENGTH BITS
	ORAA	SECTYP		;SECTION BIT
	STAA	TYPE,X
	LDAA	FOUND
	BPL	:DEFD		;ALREADY DEFINED
	ANDA	#$60		;PRESERVE LOCAL/EXTERNAL BITS
	BITA	#$20
	BNE	:DEFD		;AN EXTERNAL IS ALWAYS DEFINED
	ORAA	SECTFL		;DUMMY BIT
	EORA	#$88		;CLEAR DEFINED/LENGTH BITS
	EORA	TYPE,X		;PRESERVE LO/HI/BRANCH BITS
	STAA	TYPE,X		;COMPLEMENT GLOBAL BIT
	LDX	VALADR		;SET POINTERS
	LDAB	2,X
	LDAA	1,X
	LDX	RELPTR
	STAB	CHAIN+1,X
	STAA	CHAIN,X
	LDAB	VALADR+1
	LDAA	VALADR
	SUBB	#CHAIN-TYPE-1
	SBCA	#0
	STAB	LINK+1,X
	STAA	LINK,X
	LDAB	RELPTR+1
	LDAA	RELPTR
	LDX	CHAIN,X
	BEQ	:NIL
	STAB	LINK+1,X
	STAA	LINK,X
:NIL	LDX	VALADR
	STAB	2,X
	STAA	1,X
	LDAB	LINCNT+1
	LDAA	LINCNT
	LDX	RELPTR		;SET-UP FOR LINE NUMBER SET
	BRA	:SKIP
:DEFD	LDAA	SECTFL
	BNE	:EXIT		;A DEFINED SYMBOL WITHIN DUMMY SECTION
	SEC
	JSR	GETVAL		;SET UP FOR SYMBOL VALUE SET
:SKIP	STAB	SYMVAL+1,X	;STAB LINE+1,X
	STAA	SYMVAL,X	;STAA LINE,X
	LDAB	OBJCNT+1	;SET OFFSET
	LDAA	OBJCNT
	STAB	OFFSET+1,X
	STAA	OFFSET,X
	BCS	:GOADD5 	;DEFINED
	LDAA	TYPE,X
	ANDA	#4
	BEQ	:GOADD4 	;NOT A BRANCH
	LDAB	PC+1		;A BRANCH
	LDAA	PC
	STAB	PCNT+1,X
	STAA	PCNT,X
	INX
	INX
:GOADD4 JSR	ADD4
:GOADD5 JSR	ADD5
	STX	RELPTR
	LDX	RELCNT
	INX
	STX	RELCNT
	JMP	GC


; DISABLE .CMD DIRECTIVE

DENYCMD LDAA	CMDFL
	BNE	EXIT5		;ALREADY DENIED
	INC	CMDFL
EXIT5	RTS


; PATCH OBJECT CODE

PATCH	LDAB	LABTYP
	BEQ	EXIT5		;NO LABEL
	BITB	#8
	BNE	EXIT5		;PATCH ALREADY CALLED
	BSR	DENYCMD 	;NO .CMD FILE AFTER ANY LABELS
	ORAB	#8
	STAB	LABTYP
	LSRB
	BCC	:NOTREL 	;ABSOLUTE LABEL
	LDX	LABADR
	ANDB	#$18
	BNE	:EXTENT 	;EXTERNAL/ENTRY
	LDAB	#$18		;SET RELATIVE TYPE
:EXTENT ORAB	X
	STAB	X
:NOTREL LDX	LABVAL
	LDX	1,X
	STX	RELADR		;RELADR POINTS TO FIRST ITEM OF PATCH LIST
	LDX	LABVAL
	JSR	GETVAL
	STAB	2,X		;SET SYMBOL VALUE
	STAA	1,X
	LDAA	LABTYP
	BPL	EXIT5		;DUPLICATE LABEL
	LDX	RELADR
:LOOP	BEQ	EXIT5		;END OF PATCH LIST
	LDAA	TYPE,X
	BITA	#4
	BEQ	:NBRNCH
	LSRA			;A BRANCH
	LSRA
	LSRA
	LSRA
	LSRA
	EORA	LABTYP
	LSRA
	BCC	:ERR12		;SECTION TYPE AND SYMBOL TYPE DIFFERENT
	BITA	#$10
	BNE	:ERR12		;EXTERNAL NOT ALLOWED
	LDAA	VALUE
	SBCB	PCNT+1,X
	SBCA	PCNT,X
	CMPB	#$80		;DISPLACEMENT
	SBCA	#0
	INCA
	BEQ	:SETVAL
	LDAB	#10		;BRANCH OUT OF RANGE
	DFB	$7D
:ERR12	LDAB	#12		;INVALID EXPRESSION TYPE
	JSR	PRERRN
	LDX	RELADR
	LDAB	#$FE		;BRA .
	BRA	:ONE
:NBRNCH ANDA	#3		;BYTE/WORD
	BNE	:HILO		;HI/LO
	LDAA	VALUE		;FORCE LOW BYTE
	BNE	:ERR14		;VALUE TOO BIG
	LDAA	LABTYP
	LSRA
	BCC	:ONE		;ABSOLUTE
:ERR14	LDAB	#14		;INVALID EXPRESSION SIZE
	JSR	PRERRN
	LDX	RELADR
	INC	TYPE,X		;SET "LO" BIT
	LDAB	VALUE+1
	BRA	:ONE

; SEEK OBJECT FILE
;
; INPUT:
;   B = 0, TO SEEK THE BEGINNING
;   B = 2, TO SEEK THE END

SEEK	=	.
	STAA	TMP1		;TMP2 MUST BE ZEROED
	STAA	TMP1+1
	STAA	TMP2+1
:SEEKF	LDX	#TMP1		;SEEK FILE
	LDAA	OUTHNDL
	INT	$50
	JMP	TSTFUCK
:HILO	LSRA
	BCS	:SETVAL 	;LOW BYTE
	LDAB	VALUE		;HIGH BYTE
:ONE	CLRA			;PATCH ONE-BYTE VALUE
:SETVAL PSHB
	PSHA
	LDAB	OFFSET+1,X
	LDAA	OFFSET,X
	ADDB	OBJADJ+1
	ADCA	OBJADJ
	STAB	TMP+1		;ADDRESS TO PATCH
	STAA	TMP
	CMPA	OBJTAB
	BNE	:CMP
	CMPB	OBJTAB+1
:CMP	BCS	:OUT		;ALREADY WRITTEN TO DISK
	CMPB	OBJPTR+1
	SBCA	OBJPTR
	BCS	:IN		;IN MEMORY
:OUT	CLC
:IN	PULA
	LDAB	TYPE,X		;INSIDE DUMMY SECTION
	BITB	#$10
	BNE	:PULSET
	LDAB	LISTFL
	PULB
	BPL	:SETTYP 	;DO LISTING
	BCS	:SOFT
	STAB	TMP5		;PATCH TO DISK
	TSTA
	BEQ	:HARD
	LDAA	VALUE
	STAB	TMP5+1
	STAA	TMP5
	ADDA	CHKVAL		;CHECKSUM VALUE
	STAA	CHKVAL
	LDAA	#1
:HARD	INCA
	ADDB	CHKVAL		;CHECKSUM VALUE
	STAB	CHKVAL
	PSHA
	CLRB
	STAB	TMP1
	STAB	TMP1+1
	LDX	OFFSET,X
	STX	TMP2
	LDAA	#>SECTSIZ
	ADDA	TMP2
	STAA	TMP2
	BCC	:GOSEEK
	INC	TMP1+1
:GOSEEK BSR	:SEEKF		;SEEK CORRECT POSITION
	PULA
	STAB	TMP2
	JSR	WRTMPV		;DO PATCH
	LDAB	#2		;SEEK EOF
	BSR	SEEK
	BRA	:SETTYP
:SOFT	LDX	TMP		;PATCH TO MEMORY
	TSTA
	BEQ	:FINISH
	LDAA	VALUE
	STAA	X
	INX
:FINISH STAB	X
	ABA			;CHECKSUM VALUE
	ADDA	CHKVAL
	STAA	CHKVAL
:SETTYP LDX	RELADR
	LDAA	LABTYP
	LSRA
	ANDA	#$10		;"EXTERNAL" BIT
	ORAA	TYPE,X
	BCC	:SETABS
	ORAA	#$40		;RELATIVE
	BITA	#4
	BEQ	:SETDEF 	;NOT A BRANCH
	PSHB			;BRANCHES ARE GARBAGE
:PULSET PULB
:SETABS ANDA	#$2F		;ABSOLUTE
:SETDEF JSR	DEFTYP		;DEFINED
	BSR	GETVAL
	STAB	SYMVAL+1,X	;SET VALUE
	STAA	SYMVAL,X
	LDX	CHAIN,X 	;NEXT LIST ITEM
	STX	RELADR
	JMP	:LOOP


; EXPRESSION EVALUATING SUBROUTINES

ABSOL	BCC	:SKPTST 	;TRICK FOR PUTDECW
	ORAA	FOUND
	LSRA
	BCS	GOERR12 	;OP1 OR OP2 RELATIVE IS AN ERROR
:SKPTST LDAA	VALUE
	RTS
GOERR12 JMP	ERR12

ADD	ANDA	FOUND
	LSRA
	BCS	GOERR12 	;OP1 AND OP2 RELATIVE IS AN ERROR
	LDAA	FOUND
	LSRA
	BCC	:MAIN		;OP2 ABSOLUTE, OP1 RELATIVE, TYPE IS OP1 TYPE
	INC	FIRST		;OP1 ABSOLUTE, TYPE IS RELATIVE
:MAIN	LDAA	VALUE		;ADD VALUES
	ADDB	VAL+1
	ADCA	VAL
	RTS

SUB	LDAB	FOUND
	LSRB
	BCC	:SKIP		;OP2 ABSOLUTE, TYPE IS OP1 TYPE
	LSRA
	BCC	GOERR12 	;OP1 ABSOULUTE, OP2 RELATIVE, ERROR
	DEC	FIRST		;OP1 RELATIVE, OP2 RELATIVE, TYPE IS ABSOLUTE
:SKIP	BSR	GETVAL		;SUBTRACT VALUES
	SUBB	VAL+1
	SBCA	VAL
	RTS

MUL	BSR	MDINIT
:LOOP	ASLB			;16-BIT UNSIGNED MULTIPLY
	ROLA
	BSR	SHFTVAL
	BCC	:SKIP
	ADDB	VAL+1
	ADCA	VAL
:SKIP	DEX
	BNE	:LOOP
	RTS

SHFTVAL ASL	VALUE+1 	;TO SAVE SPACE
	ROL	VALUE
	RTS

DIV	BSR	MDINIT
:LOOP	BSR	SHFTVAL 	;16-BIT UNSIGNED DIVISION
	ROLB			;DIVISION BY ZERO RESULTS $FFFF
	ROLA
	CMPA	VAL
	BNE	:TEST
	CMPB	VAL+1
:TEST	BCS	:SKIP
	SUBB	VAL+1
	SBCA	VAL
	INC	VALUE+1
:SKIP	DEX
	BNE	:LOOP
	STAB	TMP+1		;USED BY PUTDECW

GETVAL	LDAB	VALUE+1 	;TO SAVE SPACE
	LDAA	VALUE
	RTS

MDINIT	BSR	ABSOL		;CHECK OPS TYPE
	CLRA			;SET-UP REGS FOR MUL/DIV
	TAB
	LDX	#$10
	RTS

AND	BSR	ABSOL		;CHECK OPS TYPE
	ANDB	VAL+1
	ANDA	VAL
	RTS

OR	BSR	ABSOL		;CHECK OPS TYPE
	ORAB	VAL+1
	ORAA	VAL
	RTS


; EVALUATE EXPRESSION
;
; OUTPUT:
;   X = TXTPTR
;   A = FOUND

EXPR	TSX
	STX	TMP0
	LDX	TXTPTR
	LDAB	#2		;"LO" BIT SET
	LDAA	X
	CMPA	#'<'
	BEQ	:INCTXT
	CMPA	#'>'
	BNE	:EVALZ
	ASLB			;"HI" BIT SET
:INCTXT INX
	BRA	:EVAL
:PUSH	INX
	LDAB	FIRST		;PUSH LOCAL VARIABLES FOR RECURSION
	PSHB
	LDAB	OP+1
	PSHB
	BSR	GETVAL
	PSHB
	PSHA
	STS	TMP
	LDAB	TMP+1
	LDAA	TMP
	CMPB	LIMIT+1
	SBCA	LIMIT
	BCS	:ERR1		;STACK FULL
:EVALZ	CLRB
:EVAL	ORAB	#$10		;"FIRSFL" BIT
	STAB	FIRST
	JSR	CLRVAL
	LDAB	#4		;"+"
	LDAA	X
	CMPA	#'+'
	BEQ	:SKIPCH
	CMPA	#'-'
	BNE	:SETTXT
	INCB			;"-"
:SKIPCH INX
:SETTXT STX	TXTPTR
:LOOP	ASLB
	STAB	OP+1
	LDX	TXTPTR
	LDAA	X
	CMPA	#'('
	BEQ	:PUSH
	BSR	TERM
	LDAA	FIRST
:DOMATH BITA	#$10
	BNE	:SKIP
	TSTA			;FORWARD REFERENCES NOT ALLOWED IN 2ND TERM
	BMI	:ERR11		;PRESENT
	LDAA	FOUND
	BPL	:SKIP		;FORWARD REFERENCES NOT ALLOWED AFTER 1ST TERM
:ERR11	JMP	ERR11
:ERR1	LDAB	#1		;STACK FULL
	JMP	ERROR
:SKIP	LDAA	#>SUBTBL
	STAA	OP
	LDX	OP
	LDX	<SUBTBL,X
	LDAB	VALUE+1
	LDAA	FIRST
	SEC			;FOR ABSOL
	JSR	X		;CALL OP SUBROUTINE
	JSR	SETVAL		;SAVE RESULT
	LDAA	FIRST
	BITA	#$10
	BEQ	:GETOP
	LDAB	FOUND		;FOR FIRST TIME
	ANDB	#$E0		;FOUND/LOCAL/EXTERNAL BITS
	ANDA	#7		;HI/LO/RELATIVE BITS
	ABA
	STAA	FIRST
:GETOP	LDX	TXTPTR
	LDAA	X
	INX
	STX	TXTPTR
	CMPA	#')'
	BNE	:NOPAR
	TSX
	CPX	TMP0
	BEQ	GOUNEXP 	;PARENTHESIS WASN'T OPEN
	JSR	GETVAL		;PULL LOCAL VARIABLES
	JSR	PUTVAL
	PULA
	PULB
	JSR	SETVAL
	PULA
	STAA	OP+1
	PULA
	STAA	FIRST
	BRA	:DOMATH
:NOPAR	TAB
	ANDB	#7
	STAB	OP+1		;HASH ADDRESS
	LDX	OP
	CMPA	<OPTBL,X
	BEQ	:LOOP		;ANOTHER OP
	TSX
	CPX	TMP0
	BNE	GOUNEXP 	;PARENTHESIS NOT CLOSED
	LDX	TXTPTR
	DEX
	STX	TXTPTR
	LDAA	FIRST
	STAA	FOUND
	RTS
:ILLCHR JMP	ERR8


; CALCULATE TERM VALUE

TERM	CLRB
	STAB	VAL
	STAB	VAL+1
	STAB	FOUND
	LDX	TXTPTR
	LDAB	X
	SUBB	#'0'
	BCS	:NOTDEC
	CMPB	#10
	BCC	:NOTDEC 	;BCC SYM CAN BE HERE
:LOOP1	STAB	TMP		;DECIMAL NUMBER
	LDAB	VAL+1
	LDAA	VAL
	CMPA	#$19
	BNE	:TSTLO
	CMPB	#$9A
:TSTLO	BCC	:ERR16		;DECIMAL OVERFLOW
	ASLB			;*10
	ROLA
	ASLB
	ROLA
	ADDB	VAL+1
	ADCA	VAL
	ASLB
	ROLA
	ADDB	TMP
	ADCA	#0
	BCS	:ERR16		;DECIMAL OVERFLOW
	BSR	PUTVAL
	INX
	LDAB	X
	SUBB	#'0'
	BCS	:EXIT
	CMPB	#10
	BCS	:LOOP1
:EXIT	STX	TXTPTR
:EXIT1	RTS
TSTEOL	=	.
	JSR	CHKEOL		;PRODUCE AN ERROR IN NOT EOL
	BNE	:EXIT1
GOUNEXP =	.
	JMP	UNEXP
:CHAR	LDAB	X		;QUOTE
	BEQ	GOUNEXP
	CMPB	#TABCHAR
	BNE	:NOTAB
	LDAB	#' '            ;TAB IS SPACE
:NOTAB	STAB	VALUE+1
	INX
	LDAA	X
	BEQ	:EXIT
	INX
	CMPA	#$27
	BEQ	:EXIT		;FINAL QUOTE
	CMPA	#TABCHAR
	BNE	:NOTTAB
	LDAA	#' '
:NOTTAB STAA	VALUE+1 	;WORD VALUE
	STAB	VALUE
	LDAA	X
	CMPA	#$27
	BNE	:EXIT		;FINAL QUOTE
	INX
	BRA	:EXIT
:ERR16	LDAB	#16		;CONSTANT TOO LARGE
	JMP	ERROR
:NOTDEC INX
	ADDB	#$C
	BEQ	:HEX		;"$"
	DECB
	BEQ	:BIN		;"%"
	CMPB	#2
	BEQ	:CHAR		;"'"
	CMPB	#9
	BNE	:SYM
	STX	TXTPTR		;"."
	LDAA	SECTYP
	BNE	:GETNOW
	INC	FOUND
:GETNOW LDAB	PC+1
	LDAA	PC
PUTVAL	=	.
	STAB	VAL+1
	BRA	:PUTHI
:BIN	BSR	TSTEOL		;BINARY NUMBER
	SUBB	#'0'
	BCS	:ILLCHR 	;NOT A BIN DIGIT
	CMPB	#2
	BCC	:ILLCHR 	;NOT A BIN DIGIT
:LOOP2	LSRB
	ROL	VAL+1
	ROL	VAL
:ERR16X BCS	:ERR16		;OVERFLOW
	INX
	LDAB	X
	SUBB	#'0'
	BCS	:EXIT
	CMPB	#2
	BCS	:LOOP2
:EXIT11 BRA	:EXIT
:SYM	CLRB
	BSR	ADDSYM
	LDAB	SYMLEN
	BNE	:SET
	LDX	TXTPTR		;NO SYMBOL
	JSR	TSTEOL
:ILLCHR JMP	ERR8
:SET	LDX	SYMADR
	CPX	RESADR
	BNE	:SET2
	JMP	ERR12		;"X"
:SET2	CPX	LABADR
	BNE	:SET1
	STAB	TMP3		;POTENTIAL RECURSION
:SET1	LDAB	#1
	ORAB	FOUND
:SET3	STAB	FOUND
	BMI	:EXIT3		;NOT DEFINED, ALWAYS RELATIVE
	LDAA	X
	ANDA	#$18
	BNE	:SETVAL
	STAA	FOUND		;ABSOLUTE
:SETVAL LDX	VALADR
	LDAB	2,X
	STAB	VAL+1
	LDAB	#$A1
	CMPA	#$10
	BEQ	:SET3		;EXTERNAL
	LDAA	1,X
:PUTHI	STAA	VAL
:EXIT3	RTS
:HEX	JSR	TSTEOL		;HEXADECIMAL NUMBER
	BSR	:TSTHEX
	BCS	:ILLCHR 	;NOT A HEX DIGIT
:LOOP3	LDAA	X
	CMPA	#'@'
	BCS	:SHIFT4
	ANDA	#$DF		;UPCASE LETTERS
	STAA	X
:SHIFT4 ASLB
	ASLB
	ASLB
	ASLB
	LDAA	#4
:MUL16	ASLB
	ROL	VAL+1
	ROL	VAL
	BCS	:ERR16X
	DECA
	BNE	:MUL16
	INX
	LDAB	X
	BSR	:TSTHEX
	BCC	:LOOP3
	BRA	:EXIT11
:TSTHEX LDAA	#9		;FIND OUT IF A HEX DIGIT
	SUBB	#'0'
	CBA
	BCC	:EXIT2		;NUMBER
	ADDB	#$C9
	CMPB	#$FA
	BCC	:EXIT2		;LOWERCASE
	ADDB	#$20
	CMPB	#$FA		;UPPERCASE
:EXIT2	RTS


; ADD SYMBOL TO SYMBOL TABLE
;
; INPUT:
;   B = 0 TO ADD LABEL
;   B = $20 TO ADD OPCODE
;   C = 0 IF USING LABEL
;   C = 1 TO DEFINE SYMBOL

ADDSYM	PSHB
	TPA
	PSHA
	JSR	FINDSYM 	;FIND THE SYMBOL
	PULA
	TAP
	PULB
	LDAA	SYMLEN
	BEQ	:EXIT		;NO SYMBOL
	LDAA	FOUND
	BMI	:PUT		;WAS NOT FOUND
	LDX	SYMADR
	LDAB	X
	BPL	:NOTDEF 	;WAS NOT DEFINED
	ORAB	#$40		;SET "USED" BIT
	BCS	:EXIT		;DUPLICATE SYMBOL
:SETTYP STAB	X
:EXIT	RTS
:NOTDEF ORAB	#$80		;SET "DEFINED" BIT
	ORAA	#$80
	STAA	FOUND
	BCS	:SETTYP
	RTS
:PUT	ORAB	SYMLEN
	DECB
	ORAB	#$40		;SET "USED" BIT
	BCC	:PUT1
	EORB	#$C0		;SET "DEFINED" BIT, CLEAR "USED" BIT
:PUT1	STS	TMP
	LDX	SYMPTR
	ASLA
	BPL	:PUT2		;A GLOBAL ONE
	LDX	LCLPTR
:PUT2	SEI			;MOVE NAME INTO PROPER SYMBOL TABLE
	TXS
	CLRA
	PSHA			;ZERO VALUE
	PSHA
	STS	VALADR
	LDX	CHRSYM
	INX
:MOVE	DEX
	LDAA	X
	PSHA
	CPX	SYMCHR
	BNE	:MOVE
	LDAA	FOUND
	ASLA
	BPL	:SETGBL 	;A GLOBAL ONE
	STS	LCLPTR
	BRA	:SETLCL
:SETGBL STS	SYMPTR
:SETLCL STS	SYMADR
	PSHB
	LDS	TMP
	CLI
	LDX	HASHPTR 	;SET POINTER INTO HASH TABLE
	LDAB	SYMADR+1
	STAB	1,X
	LDAB	SYMADR
	STAB	0,X
	TSTA
	BMI	:TSTLCL
	LDX	SYMCNT		;A GLOBAL ONE
	INX
	STX	SYMCNT
	CPX	#SYMBOLS
	BEQ	ERR2
:TSTGBG JMP	GC		;EXIT
:TSTLCL LDX	LCLCNT		;A LOCAL ONE
	INX
	STX	LCLCNT
	CPX	#LOCALS
	BNE	:TSTGBG
ERR2	LDAB	#2		;SYMBOL TABLE FULL
	JMP	ERROR


; FIND SYMBOL IN SYMBOL TABLE
;
; INPUT:
;   B = 0 TO FIND LABEL
;   B = $20 TO FIND OPCODE

FINDOP	LDAB	#$20		;FIND RESERVED SYMBOL
FINDSYM STAB	FOUND
	CLRB
	STAB	SYMLEN
	STAB	HASHPTR
	STAB	HASHPTR+1
	LDX	TXTPTR
	STX	SYMCHR
	LDAA	X
	CMPA	#'@'
	BCS	:TSTLCL 	;NOT A LETTER
:LOOP	ANDA	#$DF		;UPCASE
	STAA	X
:LOOP2	CMPB	#MAXSLEN
	BEQ	:SKIP		;TOO LONG
	STX	CHRSYM
	PSHB
	STAA	TMP		;HASH FUNCTION
	LDAB	HASHPTR+1
	LDAA	HASHPTR
	ASLB
	ROLA
	ROLB
	ROLA
	ROLB
	ROLA
	ROLB
	ROLA
	ROLB
	ROLA
	BCC	:CLEARB
	ORAB	#$10
:CLEARB EORB	TMP
	STAB	HASHPTR+1
	STAA	HASHPTR
	PULB
	INCB
:SKIP	INX
	BRA	:SECOND
:TSTLCL CMPA	#':'
	BNE	:DONE
	INX			;LOCAL SYMBOL
	STX	SYMCHR
	LDAA	#$80		;"LOCAL" BIT
	ORAA	FOUND
	STAA	FOUND
:SECOND LDAA	X
	CMPA	#'@'
	BCC	:LOOP		;LETTER
	CMPA	#'0'
	BCC	:LOOP2		;DIGIT
	STX	TXTPTR
	STAB	SYMLEN
	BEQ	:DONE		;FOR ":" SYMBOL
	LDAB	HASHPTR+1	;CALC HASH ADDRESS
	LDAA	HASHPTR
	ASLB
	ROLA
	TST	FOUND		;CHOOSE THE PROPER TABLE
	BMI	:LOCAL
	ANDA	#>SYMBOLS*2-1
	ADDB	HASHTAB+1
	ADCA	HASHTAB
	BRA	:GLOBAL
:LOCAL	ANDA	#>LOCALS*2-1
	ADDB	LCLHASH+1
	ADCA	LCLHASH
:GLOBAL STAB	HASHPTR+1
	STAA	HASHPTR
	STS	TMP
	LDX	HASHPTR
	SEI
:FIND	STX	HASHPTR
	SEC
	LDX	X
	BEQ	:EXIT		;EMPTY ENTRY IN TABLE, END SEARCH
	LDAB	X
	ANDB	#7
	INCB
	CMPB	SYMLEN
	BNE	:NEXT		;LENGTH ISN'T THE SAME
	LDAA	X
	EORA	FOUND
	ANDA	#$20
	BNE	:NEXT		;TYPE DOESN'T MATCH
	STX	SYMADR
	INX
	TXS
	LDX	SYMCHR
:COMP	PULA
	CMPA	X
	BNE	:NEXT		;NAME DOESN'T MATCH
	INX
	DECB
	BNE	:COMP
	STS	VALADR
:EXIT	LDS	TMP
:DONE	ROR	FOUND		;SET "FOUND" BIT, SHIFT "LOCAL" BIT
	CLI
	RTS
:NEXT	LDX	HASHPTR 	;NEXT ENTRY IN HASH TABLE
	INX
	INX
	CPX	BUFTAB
	BEQ	:INIGBL
	CPX	RELTAB
	BNE	:FIND
	LDX	LCLHASH
	DFB	$7D
:INIGBL LDX	HASHTAB
	BRA	:FIND


; NEW LINE

NL	LDX	#CRLF		;PRINT CR,LF
	BRA	SPECIAL


; PRINT ERROR MESSAGE
;
; INPUT:
;   B = ERROR CODE
;   X = ERROR LINE

PRERR11 LDAB	#11		;UNDEFINED SYMBOL
PRERRN	LDX	LINE,X
	DFB	$7D
PRERRL	LDX	LINCNT
	STX	TMP
PRERRX	LDAA	#BELL
	INT	$22
	LDAA	#CR
	INT	$22
	TSTB
	BEQ	SPECIAL 	;PRINT MESSAGE ONLY
	PSHB
	LDX	#ERRTXT 	;FIND MESSAGE ADDRESS
:LOOP	INX
	LDAA	X
	BNE	:LOOP
	DECB
	BNE	:LOOP
	INX
	PULB
:FOUND	INT	$23		;PRINT ERROR TEXT
	CMPB	#4
	BCC	:LINOUT
	BSR	NL		;CRITICAL ERROR
	INT	$38
:LINOUT STX	TMP4
	LDX	#ALLERR 	;IN LINE
	INT	$23
	LDX	TMP
	BSR	PRDECW
	STX	TMP
	LDX	ERRCNT		;ONE MORE ERROR
	INX
	STX	ERRCNT
	BSR	NL
	LDAA	LISTFL
	BMI	PRLNUM		;NO LISTING
	CLRA			;ECHO ERROR MESSAGE TO LISTING
	JSR	NEWLINE
	JSR	TABOUT
	LDX	TMP4
	BSR	ECHOSTR
	LDX	#ALLERR
	BSR	ECHOSTR
	LDX	TMP
	BSR	ECHOSTR


; PRINT LINE NUMBER

PRLNUM	LDX	#TWOSPC 	;PRINT LINE NUMBER DURING ASSEMBLY
	INT	$23
	LDX	LINCNT


; PRINT DECIMAL WORD
;
; INPUT:
;   X = WORD

PRDECW	BSR	PUTDECW
SPECIAL INT	$23
CRERR	LDAA	#3		;DOS CRITICAL ERROR HANDLER
	RTS


; PUT DECIMAL WORD INTO MNEMBUF
;
; INPUT:
;   X = WORD
; OUTPUT:
;   X = POINTER TO WORD STRING

PUTDECW JSR	GETVAL		;SAVE VALUE ON STACK
	PSHB
	PSHA
	STX	VALUE
	LDX	#MNEMBUF+5
	STX	TMP1
	LDAB	#10
	CLRA
	STAA	MNEMBUF+5
	JSR	PUTVAL
:PSHW	CLRA			;CLC
	JSR	DIV		;DIVIDE BY 10
	LDAB	TMP+1		;REMAINDER
	LDX	TMP1
	DEX
	ORAB	#'0'
	STAB	X
	STX	TMP1
	LDX	VALUE
	BNE	:PSHW
	PULA
	PULB
	LDX	TMP1
SETVAL	STAB	VALUE+1
	STAA	VALUE
	RTS


; ECHO STRING TO THE LISTING FILE
;
; INPUT:
;   X = STRING ADDRESS

:FOUND	JMP	WRTMPL
ECHOSTR =	.		;ECHO ASCIIZ STRING TO THE LISTING
	STX	TMP1
	CLRA
:FIND	LDAB	X
	BEQ	:FOUND
	INCA
	INX
	BRA	:FIND


	ERR	.-:FIND&7	;FOR IT IS ACCESSED BY EXPR


; MATH OPERATORS TABLE

OPTBL	=	.-1
	DFB	'!*+?-&/'


; JUMP TABLE FOR MATH OPERATORS IN EXPR

SUBTBL	=	.-2		;MUST BE AT THE SAME PAGE AS OPTBL
	DW	OR
	DW	MUL
	DW	ADD
	DW	ADD
	DW	SUB
	DW	AND
	DW	DIV


	ERR	SUBTBL/$100-(OPTBL/$100)


; VARIOUS MESSAGES

ERRTXT	ASC	'I/O error: '
	ASC	'Stack full'
	ASC	'Symbol table full'
	ASC	'Memory full'
	ASC	'Symbol already defined'
	ASC	'Illegal char in label'
	ASC	'Invalid opcode'
	ASC	'Illegal char in opcode'
	ASC	'Illegal char in operand'
	ASC	'Invalid addressing mode'
	ASC	'Branch out of range'
	ASC	'Undefined symbol'
	ASC	'Invalid expression type'
	ASC	'Missing label'
	ASC	'Invalid expression size'
	ASC	'Unexpected end of field'
	ASC	'Constant too large'
	ASC	'Opcode not allowed'
	ASC	'User break'
ALLERR	ASC	' in line '
TWOSPC	ASC	CR,'  '
GIVEME	ASC	'Give a value for '
LINMES	ASC	' lines',CR,LF,CR,LF,'Errors:  '
SYMMES	ASC	CR,LF,'Symbols: '
OBJMES	ASC	CR,LF,'Bytes:   '
MEMMES	DFB	' bytes free memory.'
CRLF	ASC	CR,LF
INIMES	DFB	CR,LF,FF,CR,LF,'  Symbol table - alphabetical order:',CR,LF
MESLEN	=	.-INIMES
SPACES	DFB	'       '


; INIT VARIABLES, ETC.
;
; THIS ROUTINE IS OVERLAID BY WORK AREAS
; (SECTOR BUFFER, LOCAL HASH TABLE)

INITASM CLI
	LDX	#MAINMES	;PRINT MY MESSAGE
	INT	$23
	LDX	#CRERR		;DOS CRITICAL ERROR
	LDAA	#7
	INT	$2F
	INT	$36
	DECA
	INT	$35		;EAT ALL OF THE AVAILABLE MEMORY
	CMPB	#>INITMEM
	BCC	:MEMOK		;CAN'T BE SMALLER THAN INITMEM
	JMP	ERR3
:MEMOK	LDX	#INITASM	;INIT SOME MEMORY POINTERS
	STX	LCLHASH
	STX	LINTAB
	SEC
	ADCA	#<ENDCOD
	ADCB	#>ENDCOD
	STAA	SYMTAB+1
	STAB	SYMTAB
	STAA	SYMPTR+1
	STAB	SYMPTR
	ADDA	#<STKSIZE
	ADCB	#>STKSIZE
	STAA	LIMIT+1
	STAB	LIMIT
	LDAA	LCLHASH
	ADDA	#>LOCALS*2+SECTSIZ
	STAA	LINTAB
	INT	$3B		;PARAMCOUNT
	CMPA	#2
	BCC	:ANAL		;MUST BE > 1
:BADXIT LDX	#USAGE
	JMP	EXITASM
:FIND	INX			;FIND LAST "\"
	LDAA	X
	BEQ	:FOUND
	CMPA	#'\'
	BNE	:FIND
:PARSE	STX	TMP		;PARSE PATHNAME
	BRA	:FIND
:FOUND	LDX	TMP
	LDAB	#'.'
:SCAN	INX			;FIND FIRST "." AFTER LAST "\"
	LDAA	X
	BEQ	:OK
	CBA
	BNE	:SCAN
:OK	STAB	X		;ADD "." TO THE NAME
	STX	TMP
	RTS
:ANAL	LDX    LINTAB
	TAB
	LDAA	#1
	INT	$3C		;GET 1ST PARAMETER
	LDAA	X
	EORA	#'/'
	BEQ	:SETLST
	LDAA	#$FF
:SETLST STAA	LISTFL		;"/L" PARAMETER
	BNE	:GOPARS
	LDAA	1,X
	ANDA	#$DF
	CMPA	#'L'
	BNE	:BADXIT
	LDAA	2,X
	BNE	:BADXIT
	DECB
	LDAA	#2
	INT	$3C		;GET INPUT NAME
:GOPARS SUBB	#2
	CMPB	#2
	BCC	:BADXIT
	STAB	TMP0
	BSR	:PARSE
	TSTA
	BNE	:NAMEOK 	;"." WAS GIVEN
	LDAB	#'6'            ;DEFAULT EXTENSION ".601"
	STAB	1,X
	LDAB	#'0'
	STAB	2,X
	INCB
	STAB	3,X
	CLR	4,X
:NAMEOK LDX	#0
	STX	BUFTAB
	STX	SYMCNT
	LDX	#LINTAB
	LDAA	#1
	INT	$4A		;OPEN INPUT FILE
	JSR	TSTFUCK
	STS	STACK
	STAB	HANDLE
	LDX	#ASMFIL 	;ASSEMBLING...
	INT	$23
	LDAA	TMP0
	BEQ	:SAME		;OUTPUT NAME NOT GIVEN
	INT	$3B
	DECA
	LDX	LINTAB		;GET OUTPUT NAME
	INT	$3C
	BSR	:PARSE
	TSTA
	BNE	:NAMEGO
:SAME	LDX	TMP
	LDAA	LISTFL
	BPL	:LSTEXT
	LDAB	#'O'            ;DEFALULT EXTENSION ".OBJ"
	STAB	1,X
	LDAB	#'B'
	STAB	2,X
	LDAB	#'J'
	STAB	3,X
	BRA	:PUTZ
:LSTEXT LDAB	#'L'            ;DEFAULT EXTENSION ".LST"
	STAB	1,X
	LDAB	#'S'
	STAB	2,X
	LDAB	#'T'
	STAB	3,X
:PUTZ	CLR	4,X
:NAMEGO CLRA
	LDX	#LINTAB
	INT	$4B		;CREATE AN OUTPUT FILE
	JSR	TSTFUCK
	STAB	OUTHNDL
	TBA
	LDX	#TMP		;TRY SEEKING AN OUTPUT FILE TO ENSURE IT IS NOT
	INT	$53		;A CHARACTER DEVICE
	JSR	TSTFUCK
	LDAA	LISTFL
	BNE	:INIPTR
	STAA	TMP2		;NEEDED BY CHROUT
	LDAA	#COPRLEN	;WRITE COPYRIGHT MESSAGE TO LISTING
	LDX	#MAINMES
	JSR	WRTMPX
:INIPTR LDAB	LINTAB+1	;INIT THE REST OF MEMORY POINTER
	LDAA	LINTAB
	SUBA	#>SECTSIZ
	STAB	BUFTAB+1
	STAA	BUFTAB
	LDX	#SECTSIZ
	STX	BUFLEN
	ADDB	#LINSIZE
	ADCA	#>SECTSIZ
	STAB	HASHTAB+1
	STAA	HASHTAB
	ADDA	#>SYMBOLS*2
	STAB	RELTAB+1
	STAA	RELTAB
	LDX	RELTAB
	STX	RELPTR
	STX	RELOBJ
	STX	RELADJ
	STX	RELGBL
	ADDB	SYMTAB+1
	ADCA	SYMTAB
	RORA			;LOCAL TABLE/OBJECT IN THE MIDDLE
	RORB
	STAB	LCLPTR+1
	STAA	LCLPTR
	LDX	LCLPTR
	STX	OBJTAB
	STX	OBJPTR
	STX	OBJADJ
	CLRB			;ZERO HASH TABLE
	LDX	HASHTAB
:INITBL STAB	X
	INX
	CPX	RELTAB
	BNE	:INITBL
	LDX	#MNEMBUF+1	;ZERO SOME VARIABLES
:INIVAR STAB	X
	INX
	CPX	#PAGLIN+1
	BNE	:INIVAR
	LDAA	#'X'            ;ADD "X" SYMBOL TO PREVENT ITS USAGE
	STAA	MNEMBUF
	JSR	:PUTSYM
	LDX	SYMADR
	STX	RESADR
	LDAB	#60		;SET OUTPUT PAGE SIZE
	STAB	PAGSIZ
	LDX	#MNEMTBL	;UNPACK INSTRUCTIONS/DIRECTIVES TO SYMBOL TABLE
:COPY	LDAA	X
	LSRA
	SEC			;TO SET THE 6TH BIT
	RORA
	LSRA
	STAA	MNEMBUF 	;1ST CHAR
	LDAB	1,X
	LDAA	0,X
	ASLB
	ROLA
	ASLB
	ROLA
	ANDA	#$1F
	ORAA	#$40		;TO SET THE 6TH BIT
	STAA	MNEMBUF+1	;2ND CHAR
	LDAA	2,X
	LDAB	1,X
	LSRB
	ANDB	#$1F
	BEQ	:EMPTY2 	;TWO CHARS ONLY
	ORAB	#$40		;TO SET THE 6TH BIT
:EMPTY2 STAB	MNEMBUF+2	;3RD CHAR
	LDAB	FIRST
	BNE	:DIRECT 	;A DIRECTIVE
	BCC	:TYPE0		;NEITHER "A", NOR "B"
	LDAB	#'A'            ;ADD "A" AFTER MNEMONIC
	BSR	:PUT
	TSTA
	BMI	:TYPE2		;2-OPERAND
	BITA	#$40
	BEQ	:PSHPUL 	;PSH/PUL
	ORAA	#$10
:TYPE2	ORAA	#$40
	DECA
:PSHPUL INCA
	LDAB	#'B'            ;ADD "B" AFTER MNEMONIC
	BSR	:PUT
	ASLA
	BVC	:NXT		;2-OPERAND/PSH/PUL
	LSRA
	EORA	#$30
	BRA	:TYPE0		;PUT THE MNEMONIC ITSELF
:DIRECT TAB			;PROCEED WITH DIRECTIVE
	RORB
	LSRB
	LSRB
	LSRB
	BEQ	:EMPTY3 	;3 CHARS ONLY
	ORAB	#$40		;4TH CHAR
:EMPTY3 LDAA	3,X
	INX
:TYPE0	BSR	:PUT		;PUT THE MNEMONIC
:NXT	INX
	INX
	INX
	CPX	#DIRMNEM
	BNE	:GOCOPY 	;MORE INSTRUCTIONS
	STAA	FIRST
:GOCOPY CPX	#ENDMNEM
	BNE	:COPY		;MORE DIRECTIVES
	LDX	#-1
	STX	EXECADR
:ZVARS	CLR	BUFBYT+1,X	;ZERO ANOTHER VARIABLES
	INX
	CPX	#SYMCNT-BUFBYT-1
	BNE	:ZVARS
	JMP	INITENT 	;GO TO THE MAIN PART
:PUT	STAB	MNEMBUF+3
	STX	TMP0
	LDAB	#$20
:PUTSYM PSHA
	LDX	#MNEMBUF
	STX	TXTPTR
	SEC
	JSR	ADDSYM
	PULA
	LDAB	FIRST
	BEQ	:SETVAL 	;AN INSTRUCTION
	LDX	TMP0		;A DIRECTIVE
	LDAB	1,X
	ANDB	#$F
:SETVAL LDX	VALADR		;SET INSTRUCTION CODE/DIRECTIVE ADDRESS
	STAA	2,X
	STAB	1,X
	LDX	TMP0
	RTS


; STANDARD 6800 INSTRUCTION TABLE

MNEMTBL DFB	$08,$82,$1B	;ABA
	DFB	$09,$07,$89	;ADC
	DFB	$09,$09,$8B	;ADD
	DFB	$0B,$89,$84	;AND
	DFB	$0C,$D9,$48	;ASL
	DFB	$0C,$E5,$47	;ASR
	DFB	$10,$C6,$24	;BCC
	DFB	$10,$E6,$25	;BCS
	DFB	$11,$62,$27	;BEQ
	DFB	$11,$CA,$2C	;BGE
	DFB	$11,$E8,$2E	;BGT
	DFB	$12,$12,$22	;BHI
	DFB	$12,$69,$85	;BIT
	DFB	$13,$0A,$2F	;BLE
	DFB	$13,$26,$23	;BLS
	DFB	$13,$28,$2D	;BLT
	DFB	$13,$52,$2B	;BMI
	DFB	$13,$8A,$26	;BNE
	DFB	$14,$18,$2A	;BPL
	DFB	$14,$82,$20	;BRA
	DFB	$14,$E4,$8D	;BSR
	DFB	$15,$86,$28	;BVC
	DFB	$15,$A6,$29	;BVS
	DFB	$18,$82,$11	;CBA
	DFB	$1B,$06,$0C	;CLC
	DFB	$1B,$12,$0E	;CLI
	DFB	$1B,$25,$4F	;CLR
	DFB	$1B,$2C,$0A	;CLV
	DFB	$1B,$61,$81	;CMP
	DFB	$1B,$DB,$43	;COM
	DFB	$1C,$30,$8C	;CPX
	DFB	$20,$42,$19	;DAA
	DFB	$21,$47,$4A	;DEC
	DFB	$21,$66,$34	;DES
	DFB	$21,$70,$09	;DEX
	DFB	$2B,$E5,$88	;EOR
	DFB	$4B,$87,$4C	;INC
	DFB	$4B,$A6,$31	;INS
	DFB	$4B,$B0,$08	;INX
	DFB	$53,$60,$6E	;JMP
	DFB	$54,$E4,$AD	;JSR
	DFB	$61,$03,$86	;LDA
	DFB	$61,$26,$8E	;LDS
	DFB	$61,$30,$CE	;LDX
	DFB	$64,$E5,$44	;LSR
	DFB	$71,$4F,$40	;NEG
	DFB	$73,$E0,$01	;NOP
	DFB	$7C,$83,$8A	;ORA
	DFB	$84,$D1,$36	;PSH
	DFB	$85,$59,$32	;PUL
	DFB	$93,$D9,$49	;ROL
	DFB	$93,$E5,$46	;ROR
	DFB	$95,$12,$3B	;RTI
	DFB	$95,$26,$39	;RTS
	DFB	$98,$82,$10	;SBA
	DFB	$98,$87,$82	;SBC
	DFB	$99,$46,$0D	;SEC
	DFB	$99,$52,$0F	;SEI
	DFB	$99,$6C,$0B	;SEV
	DFB	$9D,$03,$87	;STA
	DFB	$9D,$26,$8F	;STS
	DFB	$9D,$30,$CF	;STX
	DFB	$9D,$45,$80	;SUB
	DFB	$9D,$D2,$3F	;SWI
	DFB	$A0,$44,$16	;TAB
	DFB	$A0,$60,$06	;TAP
	DFB	$A0,$82,$17	;TBA
	DFB	$A4,$02,$07	;TPA
	DFB	$A4,$E9,$4D	;TST
	DFB	$A4,$F0,$30	;TSX
	DFB	$A6,$26,$35	;TXS
	DFB	$B8,$52,$3E	;WAI


; NON-STANDARD 6800 INSTRUCTION TABLE
;
; (* 6801: ABX,ADDD,ASLD,BHS,BLO,BRN,LDD,LSL,LSLD,LSRD,MUL,PSHX,PULX,STD,SUBD *)

	DFB	$12,$26,$24	;BHS
	DFB	$13,$1E,$25	;BLO
;	DFB	$61,$02,$86	;LDA
;	DFB	$61,$04,$C6	;LDB
	DFB	$64,$D9,$48	;LSL
;	DFB	$70,$82,$14	;NBA
;	DFB	$7C,$82,$8A	;ORA
;	DFB	$7C,$84,$CA	;ORB
;	DFB	$82,$02,$36	;PHA
;	DFB	$82,$04,$37	;PHB
;	DFB	$83,$02,$32	;PLA
;	DFB	$83,$04,$33	;PLB
;	DFB	$9D,$02,$87	;STA
;	DFB	$9D,$04,$C7	;STB
;	DFB	$C3,$E5,$88	;XOR


; 3. ASSEMBLER DIRECTIVES

DIRMNEM DFB	$0C,$C6 	;ASC
	DW	ASC
	ERR	ASC/$1000
	DFB	$1A,$16 	;CHK
	DW	CHK
	ERR	CHK/$1000
	DFB	$1B,$48 	;CMD
	DW	CMD
	ERR	CMD/$1000
	DFB	$20,$80 	;DB
	DW	DFB
	DFB	$21,$84 	;DFB
	DW	DFB
	ERR	DFB/$1000
	DFB	$24,$C0 	;DS
	DW	DS
	ERR	DS/$1000
	DFB	$25,$C0 	;DW
	DW	DW
	ERR	DW/$1000
	DFB	$2B,$88 	;END
	DW	END
	ERR	END/$1000
	DFB	$2C,$6A 	;EQU
	DW	EQU
	ERR	EQU/$1000
	DFB	$2C,$A4 	;ERR
	DW	ERR
	ERR	ERR/$1000
	DFB	$2B,$89 	;ENDS
	DW	$3000+ENDS
	ERR	ENDS/$1000
	DFB	$2B,$A8 	;ENT
	DW	ENT
	ERR	ENT/$1000
	DFB	$2E,$28 	;EXT
	DW	EXT
	ERR	EXT/$1000
	DFB	$4B,$A8 	;INT
	DW	INT
	ERR	INT/$1000
	DFB	$58,$88 	;KBD
	DW	KBD
	ERR	KBD/$1000
	DFB	$62,$67 	;LIST
	DW	$4000+LIST
	ERR	LIST/$1000
	DFB	$68,$52 	;MAIN
	DW	$E000+MAIN
	ERR	MAIN/$1000
	DFB	$7C,$8E 	;ORG
	DW	ORG
	ERR	ORG/$1000
	DFB	$80,$4E 	;PAGE
	DW	$5000+PAGE
	ERR	PAGE/$1000
	DFB	$99,$47 	;SECT
	DW	$4000+SECT
	ERR	SECT/$1000
	DFB	$9D,$24 	;STR
	DW	STR
	ERR	STR/$1000
ENDMNEM


; SOME MESSAGES USED AT INIT TIME

ASMFIL	ASC	'Assembling...',CR,LF
USAGE	ASC	'Usage: UASM [/l] <source> [output]',CR,LF
MAINMES DFB	CR,LF,' UniASM (R) Version 2.05 (C) 1989 SRDL',CR,LF
COPRLEN =	.-MAINMES
	ASC	'        Written by Todor Todorov',CR,LF,CR,LF
	DFB	$71,$06,$28,$68,$13
	ASC	'Z.V.D.'
	CHK
	DFB	0

ENDCOD	ERR	MAINMES/(LOCALS*2+SECTSIZ+INITASM)
INITMEM =	SECTSIZ+(LOCALS*2)+INITASM-.+(SYMBOLS*2)+256

