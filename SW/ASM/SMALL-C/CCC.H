;*  SMALL-C HEADER FILE

 ORG $800
; OPT NOG

;WARMS EQU $AD03
;exit EQU $AD03

fclose EQU $104
fopen EQU $108
getc EQU $10C
getchar EQU $110
gets EQU $114
putc EQU $118
putchar EQU $11C
puts EQU $120
RTSC EQU $124
isalpha EQU $128
isdigit EQU $12C
isalnum EQU $130
islower EQU $134
isupper EQU $138
isspace EQU $13C
toupper EQU $140
tolower EQU $144
strclr EQU $148
strlen EQU $14C
strcpy EQU $150
strcat EQU $154
strcmp EQU $158
exit   EQU $15C
EOF EQU -1

;  This stuff has been added to implement command line
;    parameter passing ( argc, argv    stuff ).

; FCB 86   SWITCH TO INLINE CODE
; BRA zzSTRT BRANCH AROUND LOCAL STORAGE
;
;zzARGC RMB 2
;zzXTMP RMB 2 TEMP STORE FOR X REG
;zzARGV RMB 20  ARRAY OF POINTERS
;NXTCH EQU $AD27 NEXT CHARACTER ROUTINE

;zzSTRT CLR zzARGC
; CLR zzARGC+1
; INC zzARGC+1 SET TO AT LEAST 1 PARAMETER
; LDX #$A080 POINT TO LINE BUFFER
; STX zzARGV
; LDX $AC14 GET LINE POINTER
; DEX FIX UP
; CLR 0,X MARK END OF STRING
; LDX #zzARGV+2 NEXT ADDRESS POINTER
; LDA B #9 MAX # OF ARG'S - 1

; now get the rest of arguments

;zzNEXT JSR NXTCH GET NEXT CHAR FROM LINE BUFFER
; CMP A #$0D IS IT A CR ?
; BEQ zzDONE YES -- FINISHED
; CMP A $AC02 COMPARE TO E.O.L.
; BEQ zzDONE

; INC zzARGC+1 BUMP ARGUMENT COUNTER
; LDA A $AC14 LINE BUFFER POINTER MSB
; STA A 0,X SAVE IN POINTER ARRAY
; INX
; LDA A $AC15 LINE BUFFER POINTER LSB
; DEC A FIX ADDRESS
; STA A 0,X
; INX

;zzAGAIN JSR NXTCH LETS GET TO END OF PARAMETER STRING
; CMP A #$0D
; BEQ zzDONE
; CMP A $AC02
; BEQ zzDONE
; CMP A #$20 BLANK ?
; BEQ zzMARK
; CMP A #',
; BNE zzAGAIN
;zzMARK STX zzXTMP SAVE POINTER
; LDX $AC14
; DEX
; CLR 0,X
; LDX zzXTMP
; DEC B DECREMENT MAX PARAM. COUNT
; BEQ zzDONE
; BRA zzNEXT

;zzDONE LDX $AC14
; CLR 0,X MARK THE FINAL STRING
;
;-------------------------------------------------------
;
; JSR RTSC RETURN TO INTERPRETED CODE
; FCB 2*2 LOAD VALUE
; FDB zzARGC
; FCB 2*10 PUSH ON STACK
; FCB 2*0 LOAD ADDRESS
; FDB zzARGV
; FCB 2*10 PUSH ON STACK
;
;------------------------------------------------------
;
